<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.21">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lab 5 – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-labs" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Labs</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-labs">    
        <li>
    <a class="dropdown-item" href="../../labs/lab1/lab1.html">
 <span class="dropdown-text">Lab 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab2/lab2.html">
 <span class="dropdown-text">Lab 2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab3/lab3.html">
 <span class="dropdown-text">Lab 3</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab4/lab4.html">
 <span class="dropdown-text">Lab 4</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab5/lab5.html">
 <span class="dropdown-text">Lab 5</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab6/lab6.html">
 <span class="dropdown-text">Lab 6</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab7/lab7.html">
 <span class="dropdown-text">Lab 7</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#design-and-testing-methodology" id="toc-design-and-testing-methodology" class="nav-link" data-scroll-target="#design-and-testing-methodology">Design and Testing Methodology</a>
  <ul class="collapse">
  <li><a href="#interrupts" id="toc-interrupts" class="nav-link" data-scroll-target="#interrupts">Interrupts</a></li>
  </ul></li>
  <li><a href="#technical-documentation" id="toc-technical-documentation" class="nav-link" data-scroll-target="#technical-documentation">Technical Documentation:</a>
  <ul class="collapse">
  <li><a href="#velocity-verification" id="toc-velocity-verification" class="nav-link" data-scroll-target="#velocity-verification">Velocity Verification</a></li>
  <li><a href="#polling-v.s.-interrupts" id="toc-polling-v.s.-interrupts" class="nav-link" data-scroll-target="#polling-v.s.-interrupts">Polling v.s. Interrupts</a></li>
  <li><a href="#flowchart" id="toc-flowchart" class="nav-link" data-scroll-target="#flowchart">Flowchart</a></li>
  <li><a href="#schematic" id="toc-schematic" class="nav-link" data-scroll-target="#schematic">Schematic</a></li>
  </ul></li>
  <li><a href="#results-and-discussion" id="toc-results-and-discussion" class="nav-link" data-scroll-target="#results-and-discussion">Results and Discussion</a>
  <ul class="collapse">
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul></li>
  <li><a href="#ai-prototype-summary" id="toc-ai-prototype-summary" class="nav-link" data-scroll-target="#ai-prototype-summary">AI Prototype Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 5</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- ![](elephant.png){fig-alt="A drawing of an elephant." fig-align="left" width=20%} -->
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In Lab 5, we were tasked with utilizing an STM32L432KC in order to read values of a provided motor’s built-in quadrature encoder in order to determine the speed of the motor (in rev/s). This was done through the use of interrupts that read every rising and falling edge of both of the quad. encoder’s signals, A and B, and correctly handling/interpreting the data being read using an interrupt</p>
</section>
<section id="design-and-testing-methodology" class="level2">
<h2 class="anchored" data-anchor-id="design-and-testing-methodology">Design and Testing Methodology</h2>
<p>The overall approach here is simple: enable interrupts for two GPIO input pins and use those interrupts to either increment or decrement a counter depending on the direction and speed.</p>
<section id="interrupts" class="level3">
<h3 class="anchored" data-anchor-id="interrupts">Interrupts</h3>
<p>In this implementation, the EXTI1 and EXTI2 fields within EXTICR1 were set to PA1 and PA2, respectively. Next, interrupts had to be enabled globally using the CMSIS provided <code>_enable_irq()</code> function. Using a mask bit, the IMR1 register was edited to allow for interrupts to be requested by our selected GPIO pins, while the RTSR1 and FTSR1 registers were modified to enable rising and falling edge triggers for the selected GPIO pins, respectively. Within the NVIC ISER register, EXTI interrupts were also enabled for PA1 and PA2.</p>
<p>Within the handlers, there were four cases to consider: rising/falling edges of A, rising/falling edges of B. As seen in Figure 2, when A is leading, the motor is spinning CW, and while B is leading the motor is spinning CCW. Focusing on the rising and falling edges of the leading signal and comparing it to the value of the other signal at the same moment will allow us to calculate the direction of rotation. As seen in Figure 2, the behavior of a motor spinning CW can be described by the two scenarios: A is rising when B is zero, and A falls when B is 1. The other two scenarios come from flipping the signals which will produce the opposite cases, meaning that the motor is spinning CCW. We use these four cases within the interrupt handler in order to determine whether or not to increment or decrement the counter. Using the counter, the velocity is calculated by dividing the counter by 4*PPR (pulses per revolution) provided by the spec. sheet in Figure 1.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/motor_specsheet.jpg" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Figure 1. Specifications for quadrature encoder motor.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab5_truthtable.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Figure 2. Truth table for the quadrature encoder</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/quad_encoder.gif" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
</section>
</section>
<section id="technical-documentation" class="level2">
<h2 class="anchored" data-anchor-id="technical-documentation">Technical Documentation:</h2>
<p>The Git repository containing the source code of this lab can be found here: <a href="https://github.com/jaredcarreno/e155-lab5.git">Lab 5 Repo</a>.</p>
<section id="velocity-verification" class="level3">
<h3 class="anchored" data-anchor-id="velocity-verification">Velocity Verification</h3>
<p>The measured periods of the traces shown in Figure 3 were utilized to calculate the rev/s directly from the encoder’s output signal. I also recording a video of my motor spinning, calculated how long a single period was and utilized that value to calculate the revolutions per second. Calculations are shown in Figure 5.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab5_trace_AB.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Figure 3. Traces of A and B signal when motor is running CCW at 12.00 V.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab5_trace_AB_allmeasure.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Figure 4. Measurements of A and B signal when motor is running CCW at 12.00 V.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab5_calculations1.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Figure 5. Velocity verification calculations (using traces and manual recordings).</figcaption>
</figure>
</div>
</section>
<section id="polling-v.s.-interrupts" class="level3">
<h3 class="anchored" data-anchor-id="polling-v.s.-interrupts">Polling v.s. Interrupts</h3>
<p>Given that interrupts are inherently faster since there are less processes, we already know that an interrupt-based approach is going to be faster than a polling-based approach. The issue arises in the fact that interrupts are event-driven while polling is time-driven. When an interrupt occurs, your pointer will jump into another address, the code will pause where the interrupt was triggered, and will jump back when it is done handling the interrupt. However, if we are polling every second, then in the time we are reading the values, we will miss a total of 4080 edges, since the code doesn’t pause while you’re reading any data (calculations shown in Figure 6).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab5_calculations2.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Figure 6. Calculations for the number of edges missed when polling with a delay of 1000 ms (1 s).</figcaption>
</figure>
</div>
</section>
<section id="flowchart" class="level3">
<h3 class="anchored" data-anchor-id="flowchart">Flowchart</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab5_flowchart.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Figure 7. Flowchart of the entire system.</figcaption>
</figure>
</div>
</section>
<section id="schematic" class="level3">
<h3 class="anchored" data-anchor-id="schematic">Schematic</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab5_schematic.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Figure 8. Schematic of the hardware level implementation used to verify operation.</figcaption>
</figure>
</div>
</section>
</section>
<section id="results-and-discussion" class="level2">
<h2 class="anchored" data-anchor-id="results-and-discussion">Results and Discussion</h2>
<!-- ### Testbench Simulation
![Figure 3. Simulation of lab2_jc module used to verify operation.](images/lab2_testbench.png){fig-align="center" width=100%}

![Figure 4. Simulation of mux module used to verify operation.](images/mux_testbench.png){fig-align="center" width=100%}

![Figure 5. Simulation of seven_segment module used to verify operation.](images/sevensegment_testbench.png){fig-align="center" width=100%}
-->
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
</section>
</section>
<section id="ai-prototype-summary" class="level2">
<h2 class="anchored" data-anchor-id="ai-prototype-summary">AI Prototype Summary</h2>
<p>The code produced by the LLM appears to have a similar approach to my implementation, with a very noticeable difference being the use of UART clock. Even though my implementation uses printf(), it does so without a UART clock, so it’s interesting to see the AI take an approach with something I’ve never used before.</p>
<pre><code>// ======================================================================
// ============================================================================
// main.c
// Quadrature encoder using EXTI interrupts + UART printf + direction
// ============================================================================

#include "main.h"

volatile int32_t encoder_count = 0;
volatile int32_t last_encoder_count = 0;
volatile float   encoder_velocity = 0.0f;
volatile int8_t  encoder_dir = 0;       // 1 = CW, -1 = CCW, 0 = stopped
volatile uint32_t print_counter = 0;

// ---------------------------------------------------------------------------
// UART2 initialization and printf redirection
// ---------------------------------------------------------------------------
void UART2_Init(void)
{
    // Enable GPIOA and USART2 clocks
    RCC-&gt;AHB2ENR  |= RCC_AHB2ENR_GPIOAEN;
    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_USART2EN;

    // Configure PA2 (TX) and PA3 (RX) as AF7
    GPIOA-&gt;MODER &amp;= ~(GPIO_MODER_MODE2_Msk | GPIO_MODER_MODE3_Msk);
    GPIOA-&gt;MODER |=  (0x2 &lt;&lt; GPIO_MODER_MODE2_Pos) | (0x2 &lt;&lt; GPIO_MODER_MODE3_Pos);
    GPIOA-&gt;AFR[0] &amp;= ~((0xF &lt;&lt; (2 * 4)) | (0xF &lt;&lt; (3 * 4)));
    GPIOA-&gt;AFR[0] |=  (7 &lt;&lt; (2 * 4)) | (7 &lt;&lt; (3 * 4));  // AF7 = USART2

    // Configure USART2: 115200 baud, 8N1
    USART2-&gt;BRR = SystemCoreClock / 115200; // assuming APB1 = SystemCoreClock
    USART2-&gt;CR1 = USART_CR1_TE | USART_CR1_RE | USART_CR1_UE;
}

// Retarget printf to USART2
int __io_putchar(int ch)
{
    while (!(USART2-&gt;ISR &amp; USART_ISR_TXE)); // wait for TX buffer empty
    USART2-&gt;TDR = ch;
    return ch;
}

// ---------------------------------------------------------------------------
// Encoder + EXTI setup
// ---------------------------------------------------------------------------
void Encoder_Init(void)
{
    RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN;

    // PA1 and PA2 as input with pull-ups
    GPIOA-&gt;MODER &amp;= ~(GPIO_MODER_MODE1_Msk | GPIO_MODER_MODE2_Msk);
    GPIOA-&gt;PUPDR &amp;= ~(GPIO_PUPDR_PUPD1_Msk | GPIO_PUPDR_PUPD2_Msk);
    GPIOA-&gt;PUPDR |=  (1U &lt;&lt; GPIO_PUPDR_PUPD1_Pos) | (1U &lt;&lt; GPIO_PUPDR_PUPD2_Pos);

    RCC-&gt;APB2ENR |= RCC_APB2ENR_SYSCFGEN;

    // Map EXTI lines to PA1, PA2 (EXTI1, EXTI2)
    SYSCFG-&gt;EXTICR[0] &amp;= ~(SYSCFG_EXTICR1_EXTI1_Msk | SYSCFG_EXTICR1_EXTI2_Msk);

    EXTI-&gt;IMR1  |= (EXTI_IMR1_IM1 | EXTI_IMR1_IM2);
    EXTI-&gt;RTSR1 |= (EXTI_RTSR1_RT1 | EXTI_RTSR1_RT2);
    EXTI-&gt;FTSR1 |= (EXTI_FTSR1_FT1 | EXTI_FTSR1_FT2);

    NVIC_SetPriority(EXTI1_IRQn, 2);
    NVIC_EnableIRQ(EXTI1_IRQn);
    NVIC_SetPriority(EXTI2_IRQn, 2);
    NVIC_EnableIRQ(EXTI2_IRQn);
}

// ---------------------------------------------------------------------------
// TIM2 1 ms periodic interrupt
// ---------------------------------------------------------------------------
void Timer2_Init(void)
{
    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;

    DELAY_TIM-&gt;PSC = (SystemCoreClock / 1000000) - 1; // 1 MHz tick
    DELAY_TIM-&gt;ARR = 1000 - 1;                        // 1 ms overflow
    DELAY_TIM-&gt;CNT = 0;
    DELAY_TIM-&gt;DIER |= TIM_DIER_UIE;
    DELAY_TIM-&gt;CR1  |= TIM_CR1_CEN;

    NVIC_SetPriority(TIM2_IRQn, 3);
    NVIC_EnableIRQ(TIM2_IRQn);
}

// ---------------------------------------------------------------------------
// Compute velocity (called every 1 ms by TIM2 interrupt)
// ---------------------------------------------------------------------------
void compute_velocity(void)
{
    int32_t delta = encoder_count - last_encoder_count;
    last_encoder_count = encoder_count;

    // Determine direction based on delta sign
    if (delta &gt; 0)      encoder_dir = 1;
    else if (delta &lt; 0) encoder_dir = -1;
    else                encoder_dir = 0;

    // rev/s = delta / (PPR * 4 * 0.001s)
    encoder_velocity = (float)delta / (PPR * 4.0f * 0.001f);
}

// ---------------------------------------------------------------------------
// Encoder update helper
// ---------------------------------------------------------------------------
static inline void Encoder_Update(void)
{
    uint32_t A = (GPIOA-&gt;IDR &amp; (1 &lt;&lt; 1)) ? 1 : 0;
    uint32_t B = (GPIOA-&gt;IDR &amp; (1 &lt;&lt; 2)) ? 1 : 0;

    if (A == B)
        encoder_count++;
    else
        encoder_count--;
}

// ---------------------------------------------------------------------------
// Interrupt Handlers
// ---------------------------------------------------------------------------
void EXTI1_IRQHandler(void)
{
    if (EXTI-&gt;PR1 &amp; EXTI_PR1_PIF1)
    {
        EXTI-&gt;PR1 = EXTI_PR1_PIF1;
        Encoder_Update();
    }
}

void EXTI2_IRQHandler(void)
{
    if (EXTI-&gt;PR1 &amp; EXTI_PR1_PIF2)
    {
        EXTI-&gt;PR1 = EXTI_PR1_PIF2;
        Encoder_Update();
    }
}

void TIM2_IRQHandler(void)
{
    if (DELAY_TIM-&gt;SR &amp; TIM_SR_UIF)
    {
        DELAY_TIM-&gt;SR &amp;= ~TIM_SR_UIF;

        compute_velocity();

        // Print every 100 ms
        print_counter++;
        if (print_counter &gt;= 100)
        {
            print_counter = 0;

            if (encoder_dir == 0)
                printf("Stopped (0.00 rev/s)\r\n");
            else
                printf("Speed: %.2f rev/s (%s)\r\n",
                       encoder_velocity * encoder_dir,   // signed speed
                       (encoder_dir &gt; 0) ? "CW" : "CCW");
        }
    }
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------
int main(void)
{
    SystemCoreClockUpdate();
    UART2_Init();
    Encoder_Init();
    Timer2_Init();

    printf("\r\nQuadrature Encoder + Direction Test Start\r\n");

    while (1)
    {
        __WFI(); // Sleep until interrupt
    }
}</code></pre>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/jaredcarreno\.github\.io\/e155-portfolio\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>