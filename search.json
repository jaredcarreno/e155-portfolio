[
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6",
    "section": "",
    "text": "For this project, an STM32L432KC microcontroller was paired with an ESP8266 Mikroe Click Board and a DS1722 temperature sensor in order to create a user-interactive website that would adjust the resolution of the temperature readings at the user’s request."
  },
  {
    "objectID": "labs/lab6/lab6.html#introduction",
    "href": "labs/lab6/lab6.html#introduction",
    "title": "Lab 6",
    "section": "",
    "text": "For this project, an STM32L432KC microcontroller was paired with an ESP8266 Mikroe Click Board and a DS1722 temperature sensor in order to create a user-interactive website that would adjust the resolution of the temperature readings at the user’s request."
  },
  {
    "objectID": "labs/lab6/lab6.html#design-and-testing-methodology",
    "href": "labs/lab6/lab6.html#design-and-testing-methodology",
    "title": "Lab 6",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe overall approach here was utilizing the SPI and UART pins on our main MCU, the STM32, in order to communicate with the DS1722 and ESP8266, respectively. UART would send the HTML needed to create the website to the ESP8266 and send user requests and read data from the DS1722 over SPI.\n\n\n\nFigure 1. Addresses of the DS1722.\n\n\n\n\n\nFigure 2. Bits of the configuration register and what they mean.\n\n\n\n\n\nFigure 3. Table relating the 16-bit data output to the temperature (in Celsius).\n\n\nThe readTemp() and setResolution() functions were utilized to set data resolution via the configuration register and read the MSB (most significant byte) and LSB (least significant byte) from their respective addresses (described in Figure 1). According to the user’s request, the configuration register (0x80) would be written to using the setResolution() function. In order to do so, the spiSendReceive() function was used to send the correct 8-bit value that aligns with the desired resolution, as shown in Figure 2. As for reading, the readTemp() called on spiSendReceive to first send the correct addresses we want to read from (0x01 and 0x02, as depicted in Figure 1), then send dummy bytes containing 0x00 to allow the DS1722 to respond with the temperature data. The data from 0x01 (LSB) and the data from 0x02 (MSB) were both read, concatenated into a single 16-bit number, then divided by 256 to give us the data’s corresponding temperature value according to the relationships shown in Figure 3.\nAs for the UART, a basic block of HTML code was sent to the ESP8266 to create the body and user-interactable buttons of the webpage and cast it over Wi-Fi. In the main function, a while(1) loop was utilized in order to keep checking for user resolution requests, only reading the new temperature and displaying the updated value on the webpage when a new request is sent using the sendString() UART function."
  },
  {
    "objectID": "labs/lab6/lab6.html#technical-documentation",
    "href": "labs/lab6/lab6.html#technical-documentation",
    "title": "Lab 6",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe Git repository containing the source code of this lab can be found here: Lab 6 Repo.\n\nOscilliscope Traces of SPI Transactions\n\n\n\nFigure 4. Oscilloscope trace of a user requesting 12-bit resolution temperature data.\n\n\nAs seen in the figure above, there was a successful SPI transaction that was triggered by a user input from the webpage!\n\n\nSchematic\n\n\n\nFigure 5. Schematic of the hardware level implementation used to verify operation."
  },
  {
    "objectID": "labs/lab6/lab6.html#results-and-discussion",
    "href": "labs/lab6/lab6.html#results-and-discussion",
    "title": "Lab 6",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nConclusion\nOverall, this lab was successful given that it was able to read temperatures and update in response to user requests."
  },
  {
    "objectID": "labs/lab6/lab6.html#ai-prototype-summary",
    "href": "labs/lab6/lab6.html#ai-prototype-summary",
    "title": "Lab 6",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe AI produced a very pretty looking website, but the value on the website would randomly update itself while nothing was connected. As for the code for reading temperature, it is trying to read the LSB and MSB from the same address, which is incorrect, and it also got the address of the LSB incorrect (0x81 instead of 0x01).\n\n\n\nFigure 6. Website produced by ChatGPT.\n\n\n\nCorresponding HTML code\n&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\" /&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n  &lt;title&gt;Temperature Sensor Portal&lt;/title&gt;\n  &lt;meta name=\"description\" content=\"Web portal to show temperature, control LED, and choose precision\" /&gt;\n  &lt;style&gt;\n    :root{\n      --bg:#0f1724;\n      --card:#0b1220;\n      --muted:#9aa4b2;\n      --accent:#6ee7b7; /* mint */\n      --accent-2:#60a5fa; /* blue */\n      --glass: rgba(255,255,255,0.04);\n      --success:#10b981;\n      --danger:#fb7185;\n      --radius:14px;\n      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", \"Segoe UI Mono\", \"Courier New\", monospace;\n      color-scheme: dark;\n    }\n    *{box-sizing:border-box}\n    html,body{height:100%}\n    body{\n      margin:0;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background: radial-gradient(1200px 600px at 10% 10%, rgba(96,165,250,0.06), transparent), radial-gradient(800px 400px at 90% 90%, rgba(110,231,183,0.035), transparent), var(--bg);\n      color:#e6eef6;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      padding:32px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n    }\n\n    .layout{\n      width:100%;\n      max-width:1100px;\n      display:grid;\n      grid-template-columns: 420px 1fr;\n      gap:28px;\n    }\n\n    .card{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:var(--radius);\n      padding:22px;\n      box-shadow: 0 8px 30px rgba(2,6,23,0.6);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    header .brand{\n      display:flex;gap:12px;align-items:center;margin-bottom:12px\n    }\n    .logo{\n      width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent-2));display:flex;align-items:center;justify-content:center;font-weight:700;color:#052a2a;font-family:var(--mono);font-size:18px;box-shadow:0 6px 20px rgba(96,165,250,0.08);\n    }\n    h1{font-size:20px;margin:0}\n    p.lead{margin:6px 0 18px;color:var(--muted);font-size:13px}\n\n    /* Temperature big panel */\n    .thermo{\n      display:flex;gap:18px;align-items:center;padding:18px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border:1px solid rgba(255,255,255,0.02);\n    }\n    .thermo .meter{\n      width:110px;height:220px;position:relative;display:flex;align-items:end;justify-content:center;padding-bottom:10px\n    }\n    .bulb{\n      width:42px;height:42px;background:linear-gradient(180deg,#ffb4a2 0%, #ff7b6b 70%);border-radius:50%;box-shadow:0 8px 30px rgba(255,123,107,0.2);border:3px solid rgba(0,0,0,0.15);\n    }\n    .scale{\n      width:12px;height:180px;background:linear-gradient(180deg,#031321 0%, rgba(255,255,255,0.02) 100%);border-radius:8px;padding:6px;display:flex;flex-direction:column;align-items:center;justify-content:flex-end\n    }\n    .mercury{\n      width:100%;background:linear-gradient(180deg,var(--accent-2), var(--accent));border-radius:6px;transition:height 600ms cubic-bezier(.2,.9,.2,1), background 400ms;\n    }\n\n    .info{\n      flex:1;display:flex;flex-direction:column;gap:8px\n    }\n    .tempBig{font-family:var(--mono);font-size:44px;margin:0}\n    .tempSmall{color:var(--muted);font-size:13px}\n\n    .controls{display:flex;gap:12px;margin-top:12px;flex-wrap:wrap}\n    .control{background:var(--glass);border-radius:10px;padding:10px 12px;min-width:110px;text-align:center}\n    .control label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}\n    .control .value{font-weight:600;font-size:16px}\n\n    .row{display:flex;gap:12px}\n\n    /* LED card */\n    .led-panel{display:flex;flex-direction:column;gap:12px}\n    .led-visual{display:flex;align-items:center;gap:12px}\n    .led-dot{width:26px;height:26px;border-radius:999px;box-shadow:0 6px 24px rgba(0,0,0,0.6), 0 0 18px rgba(0,0,0,0.2) inset;border:2px solid rgba(255,255,255,0.06);transition:transform 220ms}\n    .led-dot.on{box-shadow:0 10px 40px rgba(96,165,250,0.18), 0 0 20px rgba(96,165,250,0.18);transform:scale(1.05)}\n\n    input[type=range]{width:100%}\n    select,input[type=number],button{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:inherit}\n    button{cursor:pointer}\n\n    /* right column */\n    .panel-list{display:grid;grid-template-columns:repeat(2,1fr);gap:16px}\n\n    .card.small{padding:16px}\n    .muted{color:var(--muted);font-size:13px}\n\n    footer{margin-top:16px;color:var(--muted);font-size:13px;text-align:center}\n\n    /* responsiveness */\n    @media (max-width:980px){\n      .layout{grid-template-columns:1fr;max-width:760px}\n      .thermo{flex-direction:row}\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=\"layout\"&gt;\n    &lt;section class=\"card\"&gt;\n      &lt;header&gt;\n        &lt;div class=\"brand\"&gt;\n          &lt;div class=\"logo\"&gt;TS&lt;/div&gt;\n          &lt;div&gt;\n            &lt;h1&gt;Temperature Sensor Portal&lt;/h1&gt;\n            &lt;p class=\"lead\"&gt;Live temperature, LED control, and precision settings — simple and responsive.&lt;/p&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/header&gt;\n\n      &lt;div class=\"thermo\" role=\"region\" aria-label=\"Temperature status\"&gt;\n        &lt;div class=\"meter\" aria-hidden=\"true\"&gt;\n          &lt;div class=\"scale\"&gt;\n            &lt;div id=\"mercury\" class=\"mercury\" style=\"height:30%\"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div style=\"margin-top:10px;display:flex;justify-content:center;width:100%\"&gt;\n            &lt;div class=\"bulb\"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"info\"&gt;\n          &lt;div&gt;\n            &lt;div style=\"display:flex;align-items:center;justify-content:space-between\"&gt;\n              &lt;div&gt;\n                &lt;div class=\"tempBig\" id=\"tempValue\"&gt;--.-°C&lt;/div&gt;\n                &lt;div class=\"tempSmall\" id=\"tempHint\"&gt;Last update: —&lt;/div&gt;\n              &lt;/div&gt;\n              &lt;div style=\"text-align:right\"&gt;\n                &lt;div class=\"control\" style=\"min-width:140px\"&gt;\n                  &lt;label for=\"unitSelect\"&gt;Unit&lt;/label&gt;\n                  &lt;select id=\"unitSelect\" aria-label=\"Select temperature unit\"&gt;\n                    &lt;option value=\"C\"&gt;Celsius (°C)&lt;/option&gt;\n                    &lt;option value=\"F\"&gt;Fahrenheit (°F)&lt;/option&gt;\n                  &lt;/select&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"controls\"&gt;\n              &lt;div class=\"control\"&gt;\n                &lt;label for=\"precision\"&gt;Precision (decimal places)&lt;/label&gt;\n                &lt;select id=\"precision\"&gt;\n                  &lt;option value=\"0\"&gt;0&lt;/option&gt;\n                  &lt;option value=\"1\" selected&gt;1&lt;/option&gt;\n                  &lt;option value=\"2\"&gt;2&lt;/option&gt;\n                  &lt;option value=\"3\"&gt;3&lt;/option&gt;\n                &lt;/select&gt;\n              &lt;/div&gt;\n\n              &lt;div class=\"control\"&gt;\n                &lt;label&gt;Auto-refresh&lt;/label&gt;\n                &lt;div style=\"display:flex;gap:8px;align-items:center;justify-content:center\"&gt;\n                  &lt;input type=\"checkbox\" id=\"autoRefresh\" checked /&gt;\n                  &lt;label for=\"autoRefresh\" class=\"muted\"&gt;every 2s&lt;/label&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n\n              &lt;div class=\"control\" style=\"min-width:160px\"&gt;\n                &lt;label&gt;Connection&lt;/label&gt;\n                &lt;div class=\"value\" id=\"connStatus\"&gt;Disconnected&lt;/div&gt;\n              &lt;/div&gt;\n\n            &lt;/div&gt;\n          &lt;/div&gt;\n\n          &lt;div style=\"margin-top:6px;color:var(--muted);font-size:13px\"&gt;Tip: Use the precision selector to reduce noise in the UI when sensor jitter is present.&lt;/div&gt;\n\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      &lt;div style=\"margin-top:18px\" class=\"led-panel\"&gt;\n        &lt;div style=\"display:flex;justify-content:space-between;align-items:center\"&gt;\n          &lt;div&gt;\n            &lt;div style=\"font-weight:700\"&gt;LED Control&lt;/div&gt;\n            &lt;div class=\"muted\"&gt;Turn the LED on/off and set brightness (0–100%).&lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div id=\"ledInfo\" class=\"muted\"&gt;Status: off&lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"led-visual\"&gt;\n          &lt;div id=\"ledDot\" class=\"led-dot\" style=\"background:#111\"&gt;&lt;/div&gt;\n          &lt;div style=\"flex:1\"&gt;\n            &lt;div style=\"display:flex;gap:8px;align-items:center\"&gt;\n              &lt;button id=\"ledToggle\"&gt;Turn ON&lt;/button&gt;\n              &lt;div style=\"flex:1\"&gt;\n                &lt;label for=\"brightness\" style=\"display:block;font-size:12px;color:var(--muted);margin-bottom:6px\"&gt;Brightness&lt;/label&gt;\n                &lt;input type=\"range\" id=\"brightness\" min=\"0\" max=\"100\" value=\"100\" /&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div style=\"display:flex;gap:8px;justify-content:flex-end\"&gt;\n          &lt;button id=\"applyLed\" style=\"padding:8px 12px;border-radius:10px\"&gt;Apply&lt;/button&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"muted\" style=\"font-size:12px\"&gt;API: &lt;code&gt;/api/temperature&lt;/code&gt; to GET {temperature: number} and &lt;code&gt;/api/led&lt;/code&gt; to POST {on: boolean, brightness: 0-100} — replace with your endpoints below.&lt;/div&gt;\n      &lt;/div&gt;\n\n      &lt;footer&gt;\n        &lt;div&gt;Built for quick integration • Accessible & mobile-friendly&lt;/div&gt;\n      &lt;/footer&gt;\n    &lt;/section&gt;\n\n    &lt;aside class=\"card\"&gt;\n      &lt;div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:10px\"&gt;\n        &lt;div style=\"font-weight:700\"&gt;Diagnostics&lt;/div&gt;\n        &lt;div style=\"font-size:13px;color:var(--muted)\"&gt;Manual controls & logs&lt;/div&gt;\n      &lt;/div&gt;\n\n      &lt;div class=\"panel-list\"&gt;\n        &lt;div class=\"card small\"&gt;\n          &lt;div style=\"font-weight:600\"&gt;Manual temperature&lt;/div&gt;\n          &lt;div class=\"muted\" style=\"margin-top:8px\"&gt;Send a single read (useful for testing)&lt;/div&gt;\n          &lt;div style=\"margin-top:10px;display:flex;gap:8px\"&gt;\n            &lt;input id=\"manualTemp\" type=\"number\" placeholder=\"e.g. 23.5\" /&gt;\n            &lt;button id=\"sendManual\"&gt;Update&lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"card small\"&gt;\n          &lt;div style=\"font-weight:600\"&gt;Polling&lt;/div&gt;\n          &lt;div class=\"muted\" style=\"margin-top:8px\"&gt;Set interval (ms)&lt;/div&gt;\n          &lt;div style=\"margin-top:10px;display:flex;gap:8px\"&gt;\n            &lt;input id=\"pollInterval\" type=\"number\" value=\"2000\" /&gt;\n            &lt;button id=\"setPoll\"&gt;Set&lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"card small\"&gt;\n          &lt;div style=\"font-weight:600\"&gt;Recent logs&lt;/div&gt;\n          &lt;div id=\"logs\" class=\"muted\" style=\"margin-top:8px;max-height:180px;overflow:auto;font-size:13px\"&gt;No logs yet.&lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"card small\"&gt;\n          &lt;div style=\"font-weight:600\"&gt;Raw JSON&lt;/div&gt;\n          &lt;pre id=\"raw\" style=\"font-size:12px;margin:8px 0;max-height:160px;overflow:auto;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;color:var(--muted)\"&gt;—&lt;/pre&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/aside&gt;\n  &lt;/div&gt;\n\n  &lt;script&gt;\n    /* Configuration: point these to your real endpoints. */\n    const CONFIG = {\n      tempEndpoint: '/api/temperature', // GET -&gt; { temperature: number }\n      ledEndpoint: '/api/led', // POST -&gt; { on: boolean, brightness: number }\n      fallbackMock: true, // if true, UI will simulate values when endpoints fail\n    };\n\n    const el = id =&gt; document.getElementById(id);\n    const tempValueEl = el('tempValue');\n    const tempHintEl = el('tempHint');\n    const mercuryEl = el('mercury');\n    const connStatusEl = el('connStatus');\n    const rawEl = el('raw');\n    const logsEl = el('logs');\n    const ledDot = el('ledDot');\n    const ledInfo = el('ledInfo');\n\n    let pollInterval = Number(el('pollInterval').value) || 2000;\n    let timer = null;\n    let precision = Number(el('precision').value);\n    let unit = el('unitSelect').value;\n    let autoRefresh = el('autoRefresh').checked;\n    let mockTemp = 22 + Math.random()*2;\n\n    function log(msg){\n      const now = new Date().toLocaleTimeString();\n      logsEl.textContent = `${now} — ${msg}\\n` + logsEl.textContent;\n    }\n\n    function setConn(connected){\n      connStatusEl.textContent = connected ? 'Connected' : 'Disconnected';\n      connStatusEl.style.color = connected ? 'var(--success)' : 'var(--muted)';\n    }\n\n    function formatTemp(val){\n      if (unit === 'F') val = val * 9/5 + 32;\n      return Number(val).toFixed(precision) + '°' + unit;\n    }\n\n    function updateUI(temp){\n      const display = formatTemp(temp);\n      tempValueEl.textContent = display;\n      tempHintEl.textContent = 'Last update: ' + new Date().toLocaleString();\n\n      // map temp to 0..100% for mercury (assumes -10..50C sensor range)\n      const celsius = unit === 'F' ? (temp - 32) * 5/9 : temp;\n      const pct = Math.min(100, Math.max(0, ((celsius + 10)/60) * 100));\n      mercuryEl.style.height = pct + '%';\n      // color shift based on value\n      if (pct &gt; 66) mercuryEl.style.background = 'linear-gradient(180deg,#ff9b6b,#ff6b6b)';\n      else if (pct &gt; 33) mercuryEl.style.background = 'linear-gradient(180deg,#f6d365,#fda085)';\n      else mercuryEl.style.background = 'linear-gradient(180deg,var(--accent-2), var(--accent))';\n    }\n\n    async function fetchTemperature(){\n      try{\n        const r = await fetch(CONFIG.tempEndpoint, {cache:'no-store'});\n        if(!r.ok) throw new Error('HTTP '+r.status);\n        const json = await r.json();\n        if(typeof json.temperature !== 'number') throw new Error('invalid payload');\n        setConn(true);\n        rawEl.textContent = JSON.stringify(json, null, 2);\n        log('Temperature read: ' + json.temperature);\n        return json.temperature;\n      }catch(err){\n        setConn(false);\n        log('Failed to fetch temperature: ' + err.message);\n        if(CONFIG.fallbackMock){\n          // gentle simulated drift\n          mockTemp += (Math.random() - 0.5) * 0.25;\n          return mockTemp;\n        }\n        throw err;\n      }\n    }\n\n    async function pollOnce(){\n      try{\n        const t = await fetchTemperature();\n        updateUI(t);\n      }catch(e){\n        // handled in fetchTemperature\n      }\n    }\n\n    function startPolling(){\n      if(timer) clearInterval(timer);\n      timer = setInterval(()=&gt;{ if(el('autoRefresh').checked) pollOnce(); }, pollInterval);\n    }\n\n    // LED controls\n    let ledState = {on:false, brightness:100};\n\n    function paintLed(){\n      if(ledState.on){\n        ledDot.classList.add('on');\n        const glow = Math.max(10, ledState.brightness);\n        ledDot.style.background = `radial-gradient(circle at 30% 25%, rgba(255,255,255,0.18), rgba(96,165,250,0.08) 8%, rgba(0,0,0,0.15) 50%), rgba(96,165,250,0.12)`;\n        ledDot.style.boxShadow = `0 10px 40px rgba(96,165,250,0.12), 0 0 ${glow/1.6}px rgba(96,165,250,0.14)`;\n      }else{\n        ledDot.classList.remove('on');\n        ledDot.style.background = '#111';\n        ledDot.style.boxShadow = '';\n      }\n      ledInfo.textContent = `Status: ${ledState.on ? 'on' : 'off'} • ${ledState.brightness}%`;\n    }\n\n    async function applyLed(){\n      const payload = { on: ledState.on, brightness: ledState.brightness };\n      try{\n        const r = await fetch(CONFIG.ledEndpoint, {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});\n        if(!r.ok) throw new Error('HTTP '+r.status);\n        const json = await r.json();\n        log('LED updated → ' + JSON.stringify(payload));\n        return json;\n      }catch(err){\n        log('Failed to update LED: ' + err.message + (CONFIG.fallbackMock ? ' (mock used)' : ''));\n        if(CONFIG.fallbackMock) return {ok:true};\n        throw err;\n      }\n    }\n\n    // UI wiring\n    el('precision').addEventListener('change', e =&gt; { precision = Number(e.target.value); log('Precision set to ' + precision); pollOnce(); });\n    el('unitSelect').addEventListener('change', e =&gt; { unit = e.target.value; pollOnce(); });\n    el('autoRefresh').addEventListener('change', e =&gt; { autoRefresh = e.target.checked; log('Auto-refresh ' + (autoRefresh? 'enabled':'disabled')); });\n\n    el('sendManual').addEventListener('click', ()=&gt;{\n      const v = Number(el('manualTemp').value);\n      if(Number.isFinite(v)){ updateUI(v); rawEl.textContent = JSON.stringify({temperature:v}, null, 2); log('Manual temperature set: ' + v); }\n    });\n\n    el('setPoll').addEventListener('click', ()=&gt;{\n      const v = Number(el('pollInterval').value);\n      if(v &gt; 200){ pollInterval = v; startPolling(); log('Polling interval set to ' + v + ' ms'); }\n    });\n\n    el('brightness').addEventListener('input', e =&gt; { ledState.brightness = Number(e.target.value); paintLed(); });\n    el('ledToggle').addEventListener('click', ()=&gt;{ ledState.on = !ledState.on; el('ledToggle').textContent = ledState.on ? 'Turn OFF' : 'Turn ON'; paintLed(); });\n    el('applyLed').addEventListener('click', async ()=&gt;{ await applyLed(); });\n\n    // init\n    paintLed();\n    startPolling();\n    pollOnce();\n\n    // convenience: keyboard shortcuts\n    document.addEventListener('keydown', e=&gt;{\n      if(e.key === 'r' && (e.ctrlKey||e.metaKey)) { e.preventDefault(); pollOnce(); log('Manual refresh (shortcut)'); }\n    });\n\n    // expose for debugging\n    window.__tsPortal = {pollOnce, applyLed, setConn};\n\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt; \n\n\nChatGPT’s C implementation\n#include \"stm32l432xx.h\"\n#include &lt;stdint.h&gt;\n\n#define DS1722_CMD_READ_TEMP_MSB  0x02\n#define DS1722_CMD_WRITE_CONFIG   0x80\n#define DS1722_CMD_READ_CONFIG    0x81\n\n// Pin definitions (PB3=SCK, PB4=MISO, PB5=MOSI, PB1=CE)\n#define DS1722_CE_PORT    GPIOB\n#define DS1722_CE_PIN     (1U &lt;&lt; 1)\n\n// Simple macros for CE control\nstatic inline void DS1722_CE_Low(void)  { DS1722_CE_PORT-&gt;BSRR = (uint32_t)DS1722_CE_PIN &lt;&lt; 16U; }\nstatic inline void DS1722_CE_High(void) { DS1722_CE_PORT-&gt;BSRR = DS1722_CE_PIN; }\n\n/**\n * @brief  Initialize SPI1 peripheral and GPIO pins for DS1722 communication.\n */\nvoid DS1722_SPI_Init(void)\n{\n    // Enable GPIOB and SPI1 clocks\n    RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOBEN;\n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SPI1EN;\n\n    // ---- GPIO Config ----\n    // PB3 (SCK), PB4 (MISO), PB5 (MOSI) -&gt; AF5 (SPI1)\n    GPIOB-&gt;MODER &= ~((3U&lt;&lt;(3*2)) | (3U&lt;&lt;(4*2)) | (3U&lt;&lt;(5*2)));  // Clear mode bits\n    GPIOB-&gt;MODER |=  ((2U&lt;&lt;(3*2)) | (2U&lt;&lt;(4*2)) | (2U&lt;&lt;(5*2)));  // Alternate function mode\n    GPIOB-&gt;AFR[0] &= ~((0xF&lt;&lt;(3*4)) | (0xF&lt;&lt;(4*4)) | (0xF&lt;&lt;(5*4)));\n    GPIOB-&gt;AFR[0] |=  ((5U&lt;&lt;(3*4)) | (5U&lt;&lt;(4*4)) | (5U&lt;&lt;(5*4))); // AF5 = SPI1\n    GPIOB-&gt;OSPEEDR |= ((3U&lt;&lt;(3*2)) | (3U&lt;&lt;(4*2)) | (3U&lt;&lt;(5*2))); // Very high speed\n    GPIOB-&gt;PUPDR &= ~((3U&lt;&lt;(3*2)) | (3U&lt;&lt;(4*2)) | (3U&lt;&lt;(5*2)));  // No pull\n    GPIOB-&gt;OTYPER &= ~((1U&lt;&lt;3) | (1U&lt;&lt;4) | (1U&lt;&lt;5));             // Push-pull\n\n    // PB1 -&gt; CE pin, general-purpose output\n    GPIOB-&gt;MODER &= ~(3U&lt;&lt;(1*2));\n    GPIOB-&gt;MODER |=  (1U&lt;&lt;(1*2));     // Output mode\n    GPIOB-&gt;OSPEEDR |= (3U&lt;&lt;(1*2));    // High speed\n    DS1722_CE_High();                 // Deselect initially\n\n    // ---- SPI1 Config ----\n    SPI1-&gt;CR1 = 0; // Reset control register\n\n    // SPI mode: Master, software NSS, 8-bit, CPOL=0, CPHA=0 (Mode 0)\n    SPI1-&gt;CR1 |= SPI_CR1_MSTR | SPI_CR1_SSI | SPI_CR1_SSM;\n\n    // Baud rate prescaler: fPCLK/16 (adjust as needed)\n    SPI1-&gt;CR1 |= SPI_CR1_BR_1;\n\n    // Enable SPI1\n    SPI1-&gt;CR1 |= SPI_CR1_SPE;\n}\n\n/**\n * @brief Perform a full-duplex SPI transfer (blocking).\n * @param tx_byte Byte to send\n * @return Received byte\n */\nstatic uint8_t DS1722_SPI_Transfer(uint8_t tx_byte)\n{\n    while (!(SPI1-&gt;SR & SPI_SR_TXE));        // Wait for TX buffer empty\n    *((__IO uint8_t *)&SPI1-&gt;DR) = tx_byte;  // Write data\n    while (!(SPI1-&gt;SR & SPI_SR_RXNE));       // Wait for RX ready\n    return *((__IO uint8_t *)&SPI1-&gt;DR);     // Return received data\n}\n\n/**\n * @brief Read temperature from DS1722.\n * @return Temperature in Celsius.\n */\nfloat DS1722_ReadTemperature(void)\n{\n    uint8_t msb, lsb;\n    uint16_t raw;\n\n    DS1722_CE_Low();\n\n    DS1722_SPI_Transfer(DS1722_CMD_READ_TEMP_MSB); // Send read command\n    msb = DS1722_SPI_Transfer(0x00);               // Read MSB\n    lsb = DS1722_SPI_Transfer(0x00);               // Read LSB\n\n    DS1722_CE_High();\n\n    raw = ((uint16_t)msb &lt;&lt; 8) | lsb;\n\n    return ((float)raw) / 256.0f; // 1 LSB = 1/256 °C\n}\n\n/**\n * @brief Configure DS1722 for continuous conversion mode.\n */\nvoid DS1722_Configure(void)\n{\n    // Configuration: continuous conversion, 12-bit resolution (0xEE)\n    // Bit7=1 to write config\n    uint8_t config = 0xEE;\n\n    DS1722_CE_Low();\n    DS1722_SPI_Transfer(DS1722_CMD_WRITE_CONFIG);\n    DS1722_SPI_Transfer(config);\n    DS1722_CE_High();\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4",
    "section": "",
    "text": "For Lab 4, we were tasked with programming our MCU to play music by producing a square wave that was then sent to a GPIO pin. This was done using timers that dictated the state of the GPIO pin, which creates a square wave with the correct frequency and duration."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab 4",
    "section": "",
    "text": "For Lab 4, we were tasked with programming our MCU to play music by producing a square wave that was then sent to a GPIO pin. This was done using timers that dictated the state of the GPIO pin, which creates a square wave with the correct frequency and duration."
  },
  {
    "objectID": "labs/lab4/lab4.html#design-and-testing-methodology",
    "href": "labs/lab4/lab4.html#design-and-testing-methodology",
    "title": "Lab 4",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe design utilizes two timers, TIM15 and TIM16. These two timers have both a GPIO mode and PWM mode, which is what we want, but they also have the same registers, which will simplify the creation of our structs. The two timers start initially at the frequency of the system clock, fsys = 80 MHz, but are divided differently. The PWM timer has a PSC of 7, which allows for a precise measurement of the timing, while the duration timer has a PSC of 7999, which allows for higher frequency resolution. This can be seen by reducing the PSC for both and seeing the wrong frequencies being produced and/or the note duration being too short if the clock is too fast.\nUsing the equations shown in Figures 1 and 2, we took advantage of the ARR (auto-reload register) which sets a value at which we want the timer’s counters to stop and reset. The pulse will stay HIGH until the counter counts to the value of ARR. This can be changed using the CCR1 register, which is set to half of the ARR value, meaning that the wave is set LOW when the counter reaches half of the ARR value. This produces a wave with 50 percent duty-cycle."
  },
  {
    "objectID": "labs/lab4/lab4.html#technical-documentation",
    "href": "labs/lab4/lab4.html#technical-documentation",
    "title": "Lab 4",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe Git repository containing the source code of this lab can be found here: Lab 4 Repo.\n\nDerivations and Calculations\nFigures 1 and 2 showcase derivation for equations that were used to determine ARR, as well as the period and the frequency of the note the system is outputting, Tnote and fnote. In Figure 3, we have the maximum/minimum frequency and duration calculations that provide justification as to why we decided to choose these prescaler PSC values. The reason why the PSC value is so important is mentioned in the Design and Testing Methodology section.\n\n\n\nFigure 1. Equations representing ARR and the resultant period, Tperiod, derived using the given equation for FCNT\n\n\n\n\n\nFigure 2. Derivation of ARR in terms of ticks per millisecond and the period of the note, Tnote. Equation for Tnote and fnote also derived.\n\n\n\n\n\nFigure 3. Minimum/maximum frequency and duration calculations.\n\n\n\n\nSchematic\n\n\n\nFigure 4. Schematic of the hardware level implementation used to verify operation.\n\n\nUsing an LM386 audio amplifier, the signal was amplified and could be controlled using a potentiometer. As shown in Figure 4, a circuit provided in amp’s datasheet is utilized in order to successfully amplify and control the volume of the signal"
  },
  {
    "objectID": "labs/lab4/lab4.html#results-and-discussion",
    "href": "labs/lab4/lab4.html#results-and-discussion",
    "title": "Lab 4",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe MCU was able to produce the correct frequencies that were provided to it for the exact duration that was specified for each note. While there were no testbenches for this specific lab, the notes and their durations were accurate using the selected values for PSC and ARR, as shown in Figure 5. Debugging here was important, so using Segger’s build and debug mode and forcing the pin to output one specific frequency was definitely very crucial to ensuring correct implementation.\n\n\n\nFigure 5. Spreadsheet showcasing the percent-error calculations for the frequency produced by the system.\n\n\n\n\nConclusion\nThe lab seemed to have no issues and was able to successfully play both Fur Elise and Mary Had a Little Lamb, but is not limited to either. This lab was definitely very difficult due to the abundance of information that had to be absorbed in order to understand what was going on. Now, I feel very able to set up registers and look through the manuals to find the correct information."
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype-summary",
    "href": "labs/lab4/lab4.html#ai-prototype-summary",
    "title": "Lab 4",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe AI was able to produce a pretty sensible response. I would attribute this to the fact that the information of our STM32 MCU is readily available, along with plenty of examples that the LLM can draw on. I will say that the AI did not mention the EGR register, which is crucial for this implementation to function properly. The LLM’s response is shown below:"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2",
    "section": "",
    "text": "In Lab 2, we used a setup similar to the one used in lab 1. This time, however, the goal was to power and program a switch-controlled dual seven-segment display using time-multiplexing and have 5 LEDs that form a binary representation of the sum of the independent switches controlling each display. Thanks to time-multiplexing, the two displays could be powered using the same number of GPIO pins by rapidly switching which display is actively getting powered at rate that makes the displays appear static to our eyes."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2",
    "section": "",
    "text": "In Lab 2, we used a setup similar to the one used in lab 1. This time, however, the goal was to power and program a switch-controlled dual seven-segment display using time-multiplexing and have 5 LEDs that form a binary representation of the sum of the independent switches controlling each display. Thanks to time-multiplexing, the two displays could be powered using the same number of GPIO pins by rapidly switching which display is actively getting powered at rate that makes the displays appear static to our eyes."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nSince this is functionally the same as what was done in lab 1 – controlling a display with a 4-bit input/switch – the seven_segment module from lab 1 could be reused, as long as the inputs rapidly switch according to the mux’s enable signal. Utilizing the same on-board high-speed oscillator (HSOSC) module that was used in lab 1, the clock signal was divided in order to drive the rate at which power is switched between displays. Using a 25-bit clock that is driven by the HSOSC’s clock signal, the mux module focuses on a specific bit of the clock in order to control the output of the mux, and the value of the enable signals, enable[0] and enable[1]. In this case, it was experimentally determined that the 18th bit of the counter, counter[18], allowed for the displays to appear static without any bleeding. Using two 2N3906 PNP transistors, the current could be selectively sent to one display at a time. Using GPIO pins, enable[0] and enable[1] were each sent to the base of an individual transistor, with the collector of the transistors each being routed to the power pins of one of the displays (more clearly shown in Figure 2).\nDepending on the value of counter[18], the mux within the mux module will output a 4-bit value, s, which will be equal to either s1 or s2 (which are 4-bit values controlled by independent switches), while the mux module updates the value of enable[0] and enable[1]. These changes are dictated by enable[0] = counter[18], enable[1] = ~counter[18], and s = counter[18] ? s1 : s2. In the top module, lab2_jc, the clock is generated using the HSOSC module then fed into the mux. The output, s, of the instantiated mux module is then fed into the seven_segment module that then decodes the value of s into its corresponding segments. These are then via GPIO to the display itself. The top module is also responsible for handling the sum of the two inputs, s1 and s2, which it then assigns to led[4:0]. It is important to note that the values of s1 and s2 control display 0 and 1, respectively."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe Git repository containing the source code of this lab can be found here: Lab 2 Repo.\n\nBlock Diagram\n\n\n\nFigure 1. Block diagram visualizing lab2_jc, seven_segment, and mux modules.\n\n\nThe block diagram shown in Figure 3 showcases the hierarchy and modules within the top level module, lab2_jc. This includes 3 submodules: HSOSC, mux, and seven_segment. An adder is also present since the top level module handles the sum of the two inputs.\n\n\nSchematic\n\n\n\nFigure 2. Schematic of the hardware level implementation used to verify operation.\n\n\nAs shown in Figure 2, the hardware used included: two 4-input dip switches, the UPduino, resistors for the base, seven segment display, and green LEDs, as well as the dual seven segment display itself. Pin assignments are also shown and the value the represent are also shown in the schematic."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\nFigure 3. Simulation of lab2_jc module used to verify operation.\n\n\nAs shown in Figure 3, the lab 2 workbench successfully demonstrated that the addition of the two input signals, s1 and s2, worked, as well as the switching of the enable signal.\n\n\n\nFigure 4. Simulation of mux module used to verify operation.\n\n\nAs shown in Figure 4, the mux testbench successfully demonstrated that the right output is provided given that enable[0] or enable[1] is high or low.\n\n\n\nFigure 5. Simulation of seven_segment module used to verify operation.\n\n\nAs shown in Figure 5, the seven_segment module successfully passed all the test vectors!\n\n\nConclusion\nIt appears that we were able to successfully control a dual seven segment display and 5 LEDs using two 4-input dip switches and time-multiplexing. Both of the testbenches ran and provided information that indicates that implementation was successful. I spent 20+ hours working on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab 2",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n  \n\n\n\nFigure 6. AI developed modules\n\n\nAfter prompting ChatGPT, it created the modules shown in Figure 6. The modules were able to compile successfully, but after a closer look, it was apparent that our approaches were slightly different, but I wasn’t entirely disappointed by the result. There are differences in syntax and the use of generate statements that I am not entirely familiar with, but the logic seems fine to me. It seems that they chose to utilize the positive and negative edges of the clock for the time-multiplexing, which is another apporoach I was thinking of when I began to develop my modules."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Engineering Portfolio",
    "section": "",
    "text": "Jared Carreño is a senior engineering major at Harvey Mudd College. He is most focused on electrical and mechanical design interested in exploring embedded systems and full system design."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Hello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 23, 2024\n\n\nJared Carreno\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1",
    "section": "",
    "text": "Lab 1 was focused on setting up, testing, and getting familiarized with the UPduino v3.1 FPGA and Nucleo-L432KC development boards. This lab entailed soldering all the necessary components and headers onto the provided E155 development board, programming the MCU and FPGA boards with Segger Embedded Studio and Radiant Lattice, respectively, and creating modules that can control LEDs and an external seven segment display. The functionality of the design portion was verified using both simulation and hardware."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1",
    "section": "",
    "text": "Lab 1 was focused on setting up, testing, and getting familiarized with the UPduino v3.1 FPGA and Nucleo-L432KC development boards. This lab entailed soldering all the necessary components and headers onto the provided E155 development board, programming the MCU and FPGA boards with Segger Embedded Studio and Radiant Lattice, respectively, and creating modules that can control LEDs and an external seven segment display. The functionality of the design portion was verified using both simulation and hardware."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\n\n\nFigure 1. Truth table relating switch inputs to LEDs and seven segment display.\n\n\nAs shown in Figure 1, a 4-input switch will control both the seven segment display and 2 separate LEDs. The seven segment display consists of 7 LEDs that each correspond to a segment. Since the display is a common anode display, each segment will be activated when the GPIO pin that it is connected to is pulled to 0V, meaning that a value of 0 will indicate that a segment is ON. All the diodes’ anodes will be connected to 3.3V that comes directly from the UPduino, while the cathode will be connected to a GPIO pin and a current-limiting resistor. Combinational logic was used to drive LEDs 0 and 1, where led[0] = s[0] ^ s[1] and led[1] = s[2] & s[3], while LED 2 was set to constantly blink at a frequency of 2.4 Hz. This was done through the use of the built-in HSOSC (high speed oscillator) that was set to 48 MHz then divided to match the correct blinking frequency.\n\n\n\nFigure 2. Calculation of how many cycles will produce a correct blinking frequency of 2.4 Hz.\n\n\nAs shown in Figure 2, calculations were performed to determine how many cycles our counter would need to count to before turning off and then back on. It was determined that for 10,000,000 cycles our LED would have to be off and then on for another 10,000,000 cycles.\n\n\n\nFigure 3. Calculation of resistors to safely operate LEDs in the seven segment display.\n\n\nAs mentioned earlier, it was important to have resistors that limit the amount of current passing through our LEDs, so the appropriate resistance was calculated using the typical operating current and forward voltage (as shown in Figure 3). It is important to note that these calculations were made using an input voltage of 5V, instead of the required 3.3V, since there were difficulties getting adequate voltage out of the UPduino’s 3.3V pin. As shown in the top half of the Figure, it is recommended to use a resistor valued at 122 ohms or greater. Given that 1000 ohm resistors were used, the actual calculations would follow the bottom half of Figure 3."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe Git repository containing the source code of this lab can be found here: Lab 1 Repo.\n\nBlock Diagram\n\n\n\nFigure 4. Block diagram visualizing lab1_jc and seven_segment modules.\n\n\nThe block diagram shown in Figure 4 showcases the different modules and how they interact within the top level module. There are two inputs, s[3:0] and reset, an HSOSC module that is used to generate the clock, a counter that is used to blink LED 2, a seven_segment module containing all the combinational logic for the seven segment display, and combinational logic that is controlling LEDs 0 and 1.\n\n\nSchematic\n\n\n\nFigure 5. Schematic of the hardware level implementation used to verify operation, where R = 1k ohms.\n\n\nThe schematic shown in Figure 5 demonstrates the hardware setup used to verify the functionality of our modules. It showcases the switches utilized to control the seven segment display and LEDs, and how it maps to the physical GPIO pins on the UPduino. The schematic illustrates the use of 1000 ohm resistors to limit the current through both the onboard LEDs and the seven segment display’s LEDs."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\nFigure 6. Simulation of lab1_jc module used to verify operation.\n\n\nFigure 6 showcases the simulation of the lab1_jc module that is responsible for controlling both the LEDs and seven segment display. As we can see, the simulation managed to pass all 16 of the test vectors, meaning it was a successful implementation. As shown in Figure 6, the values of seg and led match their expected values, seg_expected and led_expected.\n\n\n\nFigure 7. Simulation of seven_segment module used to verify operation.\n\n\nFigure 7 showcases the simulation of the seven_segment module that is responsible for controlling the seven segment display. As we can see, the simulation managed to pass all 16 of the test vectors, meaning it was a successful implementation. As shown in Figure 6, the value of seg matches the value of seg_expected."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully blinked led[2] using the on-board HSOSC and controlled the seven segment display, as well as led[1] and led[0] using the 4-input dip switch. Both of the testbenches that were created for their respective modules yielded great success. I spent 10+ hours working on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab 1",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\n\n\nAI Response\n\n\nComparing this with my own module that controls the blinking of LED 2, it is immediately clear that the syntax and structure that the LLM utilizes is not easy to read. After attempting to synthesize, the design failed immediately. The AI was unable to successfully instantiate the HSOSC module that is utilized to generate the clock. Feeding the LLM the error message, it suggested that I reorder the inputs to the HSOSC module that it attempted to instantiate. Again, this didn’t work as it should be something like: HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk));. You would imagine that an LLM would be able to catch this simple of an issue, but it struggles. A majority of the code that the LLM produced is hard to read and/or wrong. There is also the use of language that I do not totally understand, since I am still somewhat new to Verilog. This leads me to believe there is some form of overcompensation and the LLM is making it unnecessarily complicated, since this isn’t exactly a complicated module to write. It’s shocking that the LLM is performing so terribly, but this may be due to the data that it is trained on."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3",
    "section": "",
    "text": "In Lab 3, we were tasked with utilizing a keypad that is very prone to mechanical debouncing in order to display numbers on a dual seven segment display that shifted from left to right as new inputs were introduced. This builds on concepts that were utilized in Labs 1 and 2."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab 3",
    "section": "",
    "text": "In Lab 3, we were tasked with utilizing a keypad that is very prone to mechanical debouncing in order to display numbers on a dual seven segment display that shifted from left to right as new inputs were introduced. This builds on concepts that were utilized in Labs 1 and 2."
  },
  {
    "objectID": "labs/lab3/lab3.html#design-and-testing-methodology",
    "href": "labs/lab3/lab3.html#design-and-testing-methodology",
    "title": "Lab 3",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe system was broken down into two FSMs: the scan FSM and debounce FSM:\nAs shown in Figure 3, the debounce FSM waits for keyPressed to be high, when it detects that it is high, it goes into S1 that enables a counter. Once the counter reaches 50ms and keyPressed is still high, then it moves onto S2 that sets pulse HIGH, indicating that there is a valid key press than can be displayed. If the key is still pressed after it is registered, keyPressed is still HIGH, so the FSM stays in S3 until the key is released, which restarts the FSM waiting for a valid press.\nAs shown in Figure 2, the scan FSM drives the columns and has a corresponding state for each row and column combination. Using row[3:0], it will jump to the state that corresponds to the column and row, and will set the corresponding column high using colOn[3:0], which cycles through one-hot encodings that enable each column, as the each state outputs row_col = {row, colOn}. The way this is designed ensures that there will be no states where multiple rows are pressed, attempting to limit the possibility of the wrong digits being shown"
  },
  {
    "objectID": "labs/lab3/lab3.html#technical-documentation",
    "href": "labs/lab3/lab3.html#technical-documentation",
    "title": "Lab 3",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe Git repository containing the source code of this lab can be found here: Lab 3 Repo.\n\nBlock Diagram and FSMs\n\n\n\nFigure 1. Block diagram visualizing the modules contained within the top module, lab3_jc\n\n\n\n\n\nFigure 2. FSM for scan module\n\n\n\n\n\nFigure 3. FSM for debounce module\n\n\n\n\nSchematic\n\n\n\nFigure 4. Schematic of the hardware level implementation used to verify operation."
  },
  {
    "objectID": "labs/lab3/lab3.html#results-and-discussion",
    "href": "labs/lab3/lab3.html#results-and-discussion",
    "title": "Lab 3",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nWhile there were no testbenches to verify using simulation, the hardware was mostly functional – shifting numbers from right to left (previous to most recent), only registering first key that is pressed, and display the second number held in the same column once the first is released. However, there is a issue when we attempt to switch to a different column from the same row, in which it won’t register the second press if two keys in the same row are pressed at the same time then the first one is released. Overall, it’s a pretty proficient implementation that will be improved on eventually.\n\n\nConclusion\nMy final product was able to successfully work – to an extent, which is further explained in the Results and Discussion section. Overall, this lab took 60+ hours to complete."
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype-summary",
    "href": "labs/lab3/lab3.html#ai-prototype-summary",
    "title": "Lab 3",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe code produced by the AI contained a lot of syntax errors that did not allow it to synthesize. Notably, it was attempting to find an ‘out’ port, which is not something that our modules are set up to have. There were originally some errors, like the AI creating modules of the same name, but even with some of my intervention the syntax errors were still prominent. The code is shown below:\n` module clock_divider( input logic clk, // 20 MHz input clock input logic rst_n, // Active low reset output logic scan_clk // Divided clock (100–200 Hz) ); // Target clock frequency: 100 Hz // Divider for 20 MHz: 20 MHz / 100 Hz = 200,000 logic [18:0] counter; // 19-bit counter for clock division\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter &lt;= 0;\n        scan_clk &lt;= 0;\n    end else begin\n        if (counter == 199_999) begin\n            counter &lt;= 0;\n            scan_clk &lt;= ~scan_clk;  // Toggle scan clock\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\nend\nendmodule\nmodule keypad_scanner1( input logic clk, // Clock input (scan clock) input logic rst_n, // Active low reset input logic [3:0] rows, // Row signals (active low) output logic [3:0] cols, // Column signals (active low) output logic [3:0] key // Output the detected key (hex value) ); // State machine for scanning rows and columns typedef enum logic [1:0] { IDLE = 2’b00, SCAN = 2’b01, DEBOUNCE = 2’b10 } state_t;\nstate_t state, next_state;\nlogic [3:0] column_reg, last_cols;\nlogic [3:0] key_reg, last_key;\nlogic key_pressed;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state &lt;= IDLE;\n        cols &lt;= 4'b1111;  // All columns inactive\n        key_reg &lt;= 4'b0000;\n        last_cols &lt;= 4'b1111;\n    end else begin\n        state &lt;= next_state;\n    end\nend\n\n// State machine logic\nalways_ff @(state or column_reg or rows or last_cols) begin\n    case (state)\n        IDLE: begin\n            next_state = SCAN;\n            cols = 4'b1111;  // All columns inactive\n        end\n        SCAN: begin\n            // Cycle through columns, one active at a time\n            if (column_reg == 4'b1110) column_reg = 4'b1101;\n            else if (column_reg == 4'b1101) column_reg = 4'b1011;\n            else if (column_reg == 4'b1011) column_reg = 4'b0111;\n            else column_reg = 4'b1111;\n            cols = column_reg;  // Set current column\n            key_pressed = |(rows & ~cols);  // Detect key press based on row signals\n            if (key_pressed) begin\n                key_reg = rows; // Register key press based on row active\n                next_state = DEBOUNCE;\n            end else begin\n                next_state = SCAN;\n            end\n        end\n        DEBOUNCE: begin\n            // Debounce the key by ensuring release before registering new key\n            if (~|(rows & ~cols)) begin  // No key pressed\n                next_state = SCAN;\n            end else begin\n                next_state = DEBOUNCE;\n            end\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// Output the detected key\nalways_ff @(posedge clk) begin\n    if (key_pressed) key = key_reg;\n    else key = last_key;\nend\nendmodule\nmodule keypad_one_shot_registration( input logic clk, // Clock input input logic rst_n, // Active low reset input logic [3:0] rows, // Row signals from keypad (active low) output logic new_key, // Single-cycle pulse for new key press output logic [3:0] key_code // Detected key code (hex value) ); // State machine states typedef enum logic [1:0] { IDLE = 2’b00, PRESSED = 2’b01, RELEASED = 2’b10 } state_t;\nstate_t state, next_state;  // Current and next states\nlogic [3:0] last_key;       // Store the last detected key\nlogic [3:0] current_key;    // Store the current key being pressed\n\n// Key detection: any active row means a key is pressed\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state &lt;= IDLE;\n        new_key &lt;= 0;\n        last_key &lt;= 4'b0000;\n        key_code &lt;= 4'b0000;\n    end else begin\n        state &lt;= next_state;\n    end\nend\n\n// Logic for key detection (rows are active low, check if any row is pressed)\nalways_ff @(posedge clk) begin\n    if (state == IDLE && ~(|rows)) begin\n        // Detect the key code when a key is pressed (active low rows)\n        current_key &lt;= ~rows;\n    end\nend\n\n// State transition and new key pulse generation\nalways_ff @(posedge clk) begin\n    case (state)\n        IDLE: begin\n            if (~(|rows)) begin  // Detect key press (any active row)\n                next_state &lt;= PRESSED;\n                new_key &lt;= 1;  // Generate a one-shot pulse\n            end else begin\n                next_state &lt;= IDLE;\n                new_key &lt;= 0;  // No new key, reset pulse\n            end\n        end\n\n        PRESSED: begin\n            if (~(|rows)) begin  // Key is still pressed\n                next_state &lt;= PRESSED;\n                new_key &lt;= 0;  // No new key until key is released\n            end else begin\n                next_state &lt;= RELEASED;  // Key released, move to RELEASED state\n            end\n        end\n\n        RELEASED: begin\n            if (~(|rows)) begin  // Key press has been released\n                next_state &lt;= IDLE;\n                key_code &lt;= current_key;  // Capture the key code\n                last_key &lt;= current_key;\n            end else begin\n                next_state &lt;= RELEASED;\n            end\n        end\n\n        default: begin\n            next_state &lt;= IDLE;\n        end\n    endcase\nend\nendmodule\nmodule keypad_scanner2( input logic clk, // Clock input (divided clock) input logic rst_n, // Active low reset input logic [3:0] rows, // Row signals from keypad (active low) output logic [3:0] key_code, // Detected key code (4-bit hex value) output logic key_pressed // Boolean indicating key press status );\n// Define FSM states\ntypedef enum logic [1:0] {\n    SCAN_IDLE = 2'b00,         // Wait for key press\n    SCAN_COL_0 = 2'b01,        // Scan column 0\n    SCAN_COL_1 = 2'b10,        // Scan column 1\n    SCAN_COL_2 = 2'b11         // Scan column 2\n} state_t;\n\nstate_t state, next_state;    // Current and next states\nlogic [3:0] col_mask;         // Column select mask\nlogic [3:0] detected_key;     // Detected key code (4 bits)\n\n// State machine for scanning columns\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state &lt;= SCAN_IDLE;\n        col_mask &lt;= 4'b1111;  // All columns inactive initially\n    end else begin\n        state &lt;= next_state;\n    end\nend\n\n// Column scanning logic: one column is active (low) at a time\nalways_ff @(posedge clk) begin\n    case (state)\n        SCAN_IDLE: begin\n            col_mask &lt;= 4'b1111;  // No column active\n        end\n        SCAN_COL_0: begin\n            col_mask &lt;= 4'b1110;  // Only column 0 is active (low)\n        end\n        SCAN_COL_1: begin\n            col_mask &lt;= 4'b1101;  // Only column 1 is active (low)\n        end\n        SCAN_COL_2: begin\n            col_mask &lt;= 4'b1011;  // Only column 2 is active (low)\n        end\n        default: begin\n            col_mask &lt;= 4'b1111;  // Default: no column active\n        end\n    endcase\nend\n\n// Detect the key code based on the active column and row signals\nalways_ff @(posedge clk) begin\n    case (state)\n        SCAN_COL_0: begin\n            if (~rows[0]) detected_key &lt;= 4'b0001;  // Row 0, Column 0\n            else if (~rows[1]) detected_key &lt;= 4'b0100;  // Row 1, Column 0\n            else if (~rows[2]) detected_key &lt;= 4'b0111;  // Row 2, Column 0\n            else if (~rows[3]) detected_key &lt;= 4'b1000;  // Row 3, Column 0\n        end\n        SCAN_COL_1: begin\n            if (~rows[0]) detected_key &lt;= 4'b0010;  // Row 0, Column 1\n            else if (~rows[1]) detected_key &lt;= 4'b0101;  // Row 1, Column 1\n            else if (~rows[2]) detected_key &lt;= 4'b0110;  // Row 2, Column 1\n            else if (~rows[3]) detected_key &lt;= 4'b1001;  // Row 3, Column 1\n        end\n        SCAN_COL_2: begin\n            if (~rows[0]) detected_key &lt;= 4'b0011;  // Row 0, Column 2\n            else if (~rows[1]) detected_key &lt;= 4'b0110;  // Row 1, Column 2\n            else if (~rows[2]) detected_key &lt;= 4'b0111;  // Row 2, Column 2\n            else if (~rows[3]) detected_key &lt;= 4'b1011;  // Row 3, Column 2\n        end\n        default: detected_key &lt;= 4'b0000; // Default: no key detected\n    endcase\nend\n\n// Key press indicator: Any key pressed when one of the rows is active\nalways_ff @(posedge clk) begin\n    if (~(|rows))  // If any row is active, a key is pressed\n        key_pressed &lt;= 1'b1;\n    else\n        key_pressed &lt;= 1'b0;\nend\n\n// Output the detected key code\nalways_ff @(posedge clk) begin\n    key_code &lt;= detected_key;\nend\n\n// State machine transitions: cycle through the columns\nalways_ff @(posedge clk) begin\n    case (state)\n        SCAN_IDLE: next_state &lt;= SCAN_COL_0;\n        SCAN_COL_0: next_state &lt;= SCAN_COL_1;\n        SCAN_COL_1: next_state &lt;= SCAN_COL_2;\n        SCAN_COL_2: next_state &lt;= SCAN_IDLE;\n        default: next_state &lt;= SCAN_IDLE;\n    endcase\nend\nendmodule\nmodule top_level ( input logic clk, // Clock from internal oscillator input logic rst_n, // Active low reset input logic [3:0] rows, // Row signals from keypad (active low) output logic [6:0] seg_a, // Seven segment display segments for first digit output logic [6:0] seg_b, // Seven segment display segments for second digit output logic an0, // Enable signal for first digit output logic an1 // Enable signal for second digit );\n// Signals for keypad scanner and one-shot registration\nlogic [3:0] key_code;         // Detected key code\nlogic new_key;                // New key detected (one-shot signal)\nlogic key_pressed;            // Key pressed indicator\n\n// Signals for last two keys\nlogic [3:0] most_recent_key;  // Most recent key (new key)\nlogic [3:0] older_key;        // Older key (last key)\n\n// Signals for 7-segment display\nlogic [3:0] display_digit;    // Digit to be displayed on the multiplexed display\nlogic mux_select;             // Multiplexer to select which digit to display\n\n// Instantiate the keypad scanner\nkeypad_scanner2 scanner (\n    .clk(clk),\n    .rst_n(rst_n),\n    .rows(rows),\n    .key_code(key_code),\n    .key_pressed(key_pressed)\n);\n\n// Instantiate the keypad one-shot registration module\nkeypad_one_shot_registration one_shot (\n    .clk(clk),\n    .rst_n(rst_n),\n    .rows(rows),\n    .new_key(new_key),\n    .key_code(key_code)\n);\n\n// Process for shifting the last two keys (older &lt;- most recent; most recent &lt;- new)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        most_recent_key &lt;= 4'b0000;\n        older_key &lt;= 4'b0000;\n    end else if (new_key) begin\n        // Shift the keys when a new key is detected\n        older_key &lt;= most_recent_key;\n        most_recent_key &lt;= key_code;\n    end\nend\n\n// Clock divider logic to generate a slower clock for display multiplexing\nlogic clk_display;\nreg [15:0] clk_divider;  // Divider for the clock (adjust for desired multiplexing rate)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_divider &lt;= 16'b0;\n        clk_display &lt;= 0;\n    end else begin\n        // Divide the clock to get a slower rate (e.g., 60 Hz for multiplexing)\n        if (clk_divider == 16'd49999) begin  // Adjust this value for desired rate\n            clk_divider &lt;= 16'b0;\n            clk_display &lt;= ~clk_display;  // Toggle the display clock\n        end else begin\n            clk_divider &lt;= clk_divider + 1'b1;\n        end\n    end\nend\n\n// Multiplexed display logic: alternate between displaying the two digits\nalways_ff @(posedge clk_display or negedge rst_n) begin\n    if (!rst_n) begin\n        mux_select &lt;= 0;\n        display_digit &lt;= 4'b0000;\n        an0 &lt;= 1;\n        an1 &lt;= 0;\n    end else begin\n        if (mux_select) begin\n            display_digit &lt;= most_recent_key;\n            an0 &lt;= 0;\n            an1 &lt;= 1;  // Enable second digit\n        end else begin\n            display_digit &lt;= older_key;\n            an0 &lt;= 1;  // Enable first digit\n            an1 &lt;= 0;\n        end\n        mux_select &lt;= ~mux_select;  // Toggle between the two digits\n    end\nend\n\n// Instantiate the seven-segment display decoder for both digits\nseven_segment seg1(\n    .in(display_digit),\n    .out(seg_a)\n);\n\nseven_segment seg2(\n    .in(display_digit),\n    .out(seg_b)\n);\nendmodule"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5",
    "section": "",
    "text": "In Lab 5, we were tasked with utilizing an STM32L432KC in order to read values of a provided motor’s built-in quadrature encoder in order to determine the speed of the motor (in rev/s). This was done through the use of interrupts that read every rising and falling edge of both of the quad. encoder’s signals, A and B, and correctly handling/interpreting the data being read using an interrupt"
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "Lab 5",
    "section": "",
    "text": "In Lab 5, we were tasked with utilizing an STM32L432KC in order to read values of a provided motor’s built-in quadrature encoder in order to determine the speed of the motor (in rev/s). This was done through the use of interrupts that read every rising and falling edge of both of the quad. encoder’s signals, A and B, and correctly handling/interpreting the data being read using an interrupt"
  },
  {
    "objectID": "labs/lab5/lab5.html#design-and-testing-methodology",
    "href": "labs/lab5/lab5.html#design-and-testing-methodology",
    "title": "Lab 5",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe overall approach here is simple: enable interrupts for two GPIO input pins and use those interrupts to either increment or decrement a counter depending on the direction and speed.\n\nInterrupts\nIn this implementation, the EXTI1 and EXTI2 fields within EXTICR1 were set to PA1 and PA2, respectively. Next, interrupts had to be enabled globally using the CMSIS provided _enable_irq() function. Using a mask bit, the IMR1 register was edited to allow for interrupts to be requested by our selected GPIO pins, while the RTSR1 and FTSR1 registers were modified to enable rising and falling edge triggers for the selected GPIO pins, respectively. Within the NVIC ISER register, EXTI interrupts were also enabled for PA1 and PA2.\nWithin the handlers, there were four cases to consider: rising/falling edges of A, rising/falling edges of B. As seen in Figure 2, when A is leading, the motor is spinning CW, and while B is leading the motor is spinning CCW. Focusing on the rising and falling edges of the leading signal and comparing it to the value of the other signal at the same moment will allow us to calculate the direction of rotation. As seen in Figure 2, the behavior of a motor spinning CW can be described by the two scenarios: A is rising when B is zero, and A falls when B is 1. The other two scenarios come from flipping the signals which will produce the opposite cases, meaning that the motor is spinning CCW. We use these four cases within the interrupt handler in order to determine whether or not to increment or decrement the counter. Using the counter, the velocity is calculated by dividing the counter by 4*PPR (pulses per revolution) provided by the spec. sheet in Figure 1.\n\n\n\nFigure 1. Specifications for quadrature encoder motor.\n\n\n\n\n\nFigure 2. Truth table for output signals of quadrature encoder motor."
  },
  {
    "objectID": "labs/lab5/lab5.html#technical-documentation",
    "href": "labs/lab5/lab5.html#technical-documentation",
    "title": "Lab 5",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe Git repository containing the source code of this lab can be found here: Lab 5 Repo.\n\nVelocity Verification\nThe measured periods of the traces shown in Figure 3 were utilized to calculate the rev/s directly from the encoder’s output signal. I also recording a video of my motor spinning, calculated how long a single period was and utilized that value to calculate the revolutions per second. Calculations are shown in Figure 5.\n\n\n\nFigure 3. Traces of A and B signal when motor is running CCW at 12.00 V.\n\n\n\n\n\nFigure 4. Measurements of A and B signal when motor is running CCW at 12.00 V.\n\n\n\n\n\nFigure 5. Velocity verification calculations (using traces and manual recordings).\n\n\n\n\nPolling v.s. Interrupts\nGiven that interrupts are inherently faster since there are less processes, we already know that an interrupt-based approach is going to be faster than a polling-based approach. The issue arises in the fact that interrupts are event-driven while polling is time-driven. When an interrupt occurs, your pointer will jump into another address, the code will pause where the interrupt was triggered, and will jump back when it is done handling the interrupt. However, if we are polling every second, then in the time we are reading the values, we will miss a total of 4080 edges, since the code doesn’t pause while you’re reading any data (calculations shown in Figure 6).\n\n\n\nFigure 6. Calculations for the number of edges missed when polling with a delay of 1000 ms (1 s).\n\n\n\n\nFlowchart\n\n\n\nFigure 7. Flowchart of the entire system.\n\n\n\n\nSchematic\n\n\n\nFigure 8. Schematic of the hardware level implementation used to verify operation."
  },
  {
    "objectID": "labs/lab5/lab5.html#results-and-discussion",
    "href": "labs/lab5/lab5.html#results-and-discussion",
    "title": "Lab 5",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nRunning my implementation yielded the correct result – a speed close to 2.5 rev/s! The terminal output is shown below. I noticed that there was a large variability when it came to having motors that actually ran at the rated speed of 2.5 rev/s. Most motors I tested ran a little faster (2.67, 2.8, 2.9 rev/s) with only a single one running at 2.5 rev/s.\n\nTerminal Output\ncounter: 0 \nThe motor is spinning at 0.000000 rev/s \ncounter: 0 \nThe motor is spinning at 0.000000 rev/s \ncounter: 0 \nThe motor is spinning at 0.000000 rev/s \ncounter: 0 \nThe motor is spinning at 0.000000 rev/s \ncounter: 0 \nThe motor is spinning at 0.000000 rev/s \ncounter: -3708 \nThe motor is spinning at -2.271446 rev/s \ncounter: -4371 \nThe motor is spinning at -2.677696 rev/s \ncounter: -4374 \nThe motor is spinning at -2.678921 rev/s \ncounter: -4372 \nThe motor is spinning at -2.678309 rev/s \ncounter: -4374 \nThe motor is spinning at -2.679534 rev/s \ncounter: -4374 \nThe motor is spinning at -2.680147 rev/s \ncounter: -4376 \nThe motor is spinning at -2.680760 rev/s \ncounter: -4376 \nThe motor is spinning at -2.680760 rev/s \ncounter: -4376 \nThe motor is spinning at -2.680760 rev/s \ncounter: -4376 \nThe motor is spinning at -2.680760 rev/s \ncounter: -4376 \nThe motor is spinning at -2.681373 rev/s \ncounter: -4379 \nThe motor is spinning at -2.682598 rev/s \ncounter: -4378 \nThe motor is spinning at -2.681985 rev/s \ncounter: -4378 \nThe motor is spinning at -2.681985 rev/s \ncounter: -4379 \nThe motor is spinning at -2.682598 rev/s \ncounter: -3002 \nThe motor is spinning at -1.839461 rev/s \ncounter: -25 \nThe motor is spinning at -0.015319 rev/s \ncounter: 0 \nThe motor is spinning at 0.000000 rev/s \n\n\n\nConclusion\nIn conclusion, my implementation was able to successfully read the speed of a motor using its integrated quadrature encoder. This lab was really fun to do, as it demonstrated to me how to properly interface with hardware, as well as read data using a microcontroller’s interrupts. Overall, this lab took roughly 15 hours to complete."
  },
  {
    "objectID": "labs/lab5/lab5.html#ai-prototype-summary",
    "href": "labs/lab5/lab5.html#ai-prototype-summary",
    "title": "Lab 5",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe code produced by the LLM appears to have a similar approach to my implementation, with a very noticeable difference being the use of UART clock. Even though my implementation uses printf(), it does so without a UART clock, so it’s interesting to see the AI take an approach with something I’ve never used before. After running the code on my setup, I determined that the AI implementation was a working one. Output from the AI implementation is shown below.\n// ======================================================================\n// ============================================================================\n// main.c\n// Quadrature encoder using EXTI interrupts + UART printf + direction\n// ============================================================================\n\n#include \"main.h\"\n\nvolatile int32_t encoder_count = 0;\nvolatile int32_t last_encoder_count = 0;\nvolatile float   encoder_velocity = 0.0f;\nvolatile int8_t  encoder_dir = 0;       // 1 = CW, -1 = CCW, 0 = stopped\nvolatile uint32_t print_counter = 0;\n\n// ---------------------------------------------------------------------------\n// UART2 initialization and printf redirection\n// ---------------------------------------------------------------------------\nvoid UART2_Init(void)\n{\n    // Enable GPIOA and USART2 clocks\n    RCC-&gt;AHB2ENR  |= RCC_AHB2ENR_GPIOAEN;\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_USART2EN;\n\n    // Configure PA2 (TX) and PA3 (RX) as AF7\n    GPIOA-&gt;MODER &= ~(GPIO_MODER_MODE2_Msk | GPIO_MODER_MODE3_Msk);\n    GPIOA-&gt;MODER |=  (0x2 &lt;&lt; GPIO_MODER_MODE2_Pos) | (0x2 &lt;&lt; GPIO_MODER_MODE3_Pos);\n    GPIOA-&gt;AFR[0] &= ~((0xF &lt;&lt; (2 * 4)) | (0xF &lt;&lt; (3 * 4)));\n    GPIOA-&gt;AFR[0] |=  (7 &lt;&lt; (2 * 4)) | (7 &lt;&lt; (3 * 4));  // AF7 = USART2\n\n    // Configure USART2: 115200 baud, 8N1\n    USART2-&gt;BRR = SystemCoreClock / 115200; // assuming APB1 = SystemCoreClock\n    USART2-&gt;CR1 = USART_CR1_TE | USART_CR1_RE | USART_CR1_UE;\n}\n\n// Retarget printf to USART2\nint __io_putchar(int ch)\n{\n    while (!(USART2-&gt;ISR & USART_ISR_TXE)); // wait for TX buffer empty\n    USART2-&gt;TDR = ch;\n    return ch;\n}\n\n// ---------------------------------------------------------------------------\n// Encoder + EXTI setup\n// ---------------------------------------------------------------------------\nvoid Encoder_Init(void)\n{\n    RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN;\n\n    // PA1 and PA2 as input with pull-ups\n    GPIOA-&gt;MODER &= ~(GPIO_MODER_MODE1_Msk | GPIO_MODER_MODE2_Msk);\n    GPIOA-&gt;PUPDR &= ~(GPIO_PUPDR_PUPD1_Msk | GPIO_PUPDR_PUPD2_Msk);\n    GPIOA-&gt;PUPDR |=  (1U &lt;&lt; GPIO_PUPDR_PUPD1_Pos) | (1U &lt;&lt; GPIO_PUPDR_PUPD2_Pos);\n\n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SYSCFGEN;\n\n    // Map EXTI lines to PA1, PA2 (EXTI1, EXTI2)\n    SYSCFG-&gt;EXTICR[0] &= ~(SYSCFG_EXTICR1_EXTI1_Msk | SYSCFG_EXTICR1_EXTI2_Msk);\n\n    EXTI-&gt;IMR1  |= (EXTI_IMR1_IM1 | EXTI_IMR1_IM2);\n    EXTI-&gt;RTSR1 |= (EXTI_RTSR1_RT1 | EXTI_RTSR1_RT2);\n    EXTI-&gt;FTSR1 |= (EXTI_FTSR1_FT1 | EXTI_FTSR1_FT2);\n\n    NVIC_SetPriority(EXTI1_IRQn, 2);\n    NVIC_EnableIRQ(EXTI1_IRQn);\n    NVIC_SetPriority(EXTI2_IRQn, 2);\n    NVIC_EnableIRQ(EXTI2_IRQn);\n}\n\n// ---------------------------------------------------------------------------\n// TIM2 1 ms periodic interrupt\n// ---------------------------------------------------------------------------\nvoid Timer2_Init(void)\n{\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\n\n    DELAY_TIM-&gt;PSC = (SystemCoreClock / 1000000) - 1; // 1 MHz tick\n    DELAY_TIM-&gt;ARR = 1000 - 1;                        // 1 ms overflow\n    DELAY_TIM-&gt;CNT = 0;\n    DELAY_TIM-&gt;DIER |= TIM_DIER_UIE;\n    DELAY_TIM-&gt;CR1  |= TIM_CR1_CEN;\n\n    NVIC_SetPriority(TIM2_IRQn, 3);\n    NVIC_EnableIRQ(TIM2_IRQn);\n}\n\n// ---------------------------------------------------------------------------\n// Compute velocity (called every 1 ms by TIM2 interrupt)\n// ---------------------------------------------------------------------------\nvoid compute_velocity(void)\n{\n    int32_t delta = encoder_count - last_encoder_count;\n    last_encoder_count = encoder_count;\n\n    // Determine direction based on delta sign\n    if (delta &gt; 0)      encoder_dir = 1;\n    else if (delta &lt; 0) encoder_dir = -1;\n    else                encoder_dir = 0;\n\n    // rev/s = delta / (PPR * 4 * 0.001s)\n    encoder_velocity = (float)delta / (PPR * 4.0f * 0.001f);\n}\n\n// ---------------------------------------------------------------------------\n// Encoder update helper\n// ---------------------------------------------------------------------------\nstatic inline void Encoder_Update(void)\n{\n    uint32_t A = (GPIOA-&gt;IDR & (1 &lt;&lt; 1)) ? 1 : 0;\n    uint32_t B = (GPIOA-&gt;IDR & (1 &lt;&lt; 2)) ? 1 : 0;\n\n    if (A == B)\n        encoder_count++;\n    else\n        encoder_count--;\n}\n\n// ---------------------------------------------------------------------------\n// Interrupt Handlers\n// ---------------------------------------------------------------------------\nvoid EXTI1_IRQHandler(void)\n{\n    if (EXTI-&gt;PR1 & EXTI_PR1_PIF1)\n    {\n        EXTI-&gt;PR1 = EXTI_PR1_PIF1;\n        Encoder_Update();\n    }\n}\n\nvoid EXTI2_IRQHandler(void)\n{\n    if (EXTI-&gt;PR1 & EXTI_PR1_PIF2)\n    {\n        EXTI-&gt;PR1 = EXTI_PR1_PIF2;\n        Encoder_Update();\n    }\n}\n\nvoid TIM2_IRQHandler(void)\n{\n    if (DELAY_TIM-&gt;SR & TIM_SR_UIF)\n    {\n        DELAY_TIM-&gt;SR &= ~TIM_SR_UIF;\n\n        compute_velocity();\n\n        // Print every 100 ms\n        print_counter++;\n        if (print_counter &gt;= 100)\n        {\n            print_counter = 0;\n\n            if (encoder_dir == 0)\n                printf(\"Stopped (0.00 rev/s)\\r\\n\");\n            else\n                printf(\"Speed: %.2f rev/s (%s)\\r\\n\",\n                       encoder_velocity * encoder_dir,   // signed speed\n                       (encoder_dir &gt; 0) ? \"CW\" : \"CCW\");\n        }\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Main\n// ---------------------------------------------------------------------------\nint main(void)\n{\n    SystemCoreClockUpdate();\n    UART2_Init();\n    Encoder_Init();\n    Timer2_Init();\n\n    printf(\"\\r\\nQuadrature Encoder + Direction Test Start\\r\\n\");\n\n    while (1)\n    {\n        __WFI(); // Sleep until interrupt\n    }\n}\n\nTerminal Output\nQuadrature Encoder + Direction Test Start\nStopped (0.00 rev/s)\nStopped (0.00 rev/s)\nStopped (0.00 rStopped (0.topped (0.00 rev/s)\nStopped (0.00 rtopped (0.00 rev/s)\n0.00Sto0.00 rev/s)\nSpeed: 0.61 rev/s (peedpeed: 0.61 rev/s (CCW)\nStopped (0.00 repeedpeed: 0.61 rev/s (CCW)\nStopped (0.0peed: 0.61 rev/s (CC(0.00 rev/s)\nStoppe(0.0(0.00 rev/s)\nSt(0.0d (0d (0.00 rev/s)\nSpeed: 0.61 rev/s (CW)\nStopd (0.00 rev/s)\nSpeed: 0.61 rev/s (CW)\nStopd (0.00 rev/s)\nSpeed: 0.61 rev/s (CW)\nStopd (0S0.00 rev/s)\nSpeed: 0.61 rev/s (CW)\nSto0.000.00 rev/s)\nSpeed: 0.00 rev/s)\nSpeed: 0.61 rev/s (CW)\nStopped (0.00 rev/s)\nSpeed: 0.61 rev/s (CCW)\nStopped (0.00 rev/s)\nStopped (0.00 rev/s)\nSpeed: 0.61 rev/s (CW)\nStopped (0.00 rev/s)\nSpeed: 0.61 rev/s (CCW)\nStopped (0.00 rev/s)\nSpeed: 0.61 rev/s (CW)\nStopped (0.00 rev/s)\nStopped (0.00 rev/s)\nSpeed: 0.61 rev/s (CCW)\nStopped (0.00 rev/s)\nSpeed: 0.61 rev/s (CW)\nStopped (0.00 rev/s)\nSpeed: 0.61 rev/s (CCW)\nStopped (0.00 rev/s)\nSpeed: 0.61 rev/s (CW)\nStopped (0.00 rev/s)\nStopped (0.00 rev/s)\nStopped (0.00 rev/s)"
  }
]