[
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4",
    "section": "",
    "text": "For Lab 4, we were tasked with programming our MCU to play music by producing a square wave that was then sent to a GPIO pin. This was done using timers that dictated the state of the GPIO pin, which creates a square wave with the correct frequency and duration."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab 4",
    "section": "",
    "text": "For Lab 4, we were tasked with programming our MCU to play music by producing a square wave that was then sent to a GPIO pin. This was done using timers that dictated the state of the GPIO pin, which creates a square wave with the correct frequency and duration."
  },
  {
    "objectID": "labs/lab4/lab4.html#design-and-testing-methodology",
    "href": "labs/lab4/lab4.html#design-and-testing-methodology",
    "title": "Lab 4",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe design utilizes two timers, TIM15 and TIM16. These two timers have both a GPIO mode and PWM mode, which is what we want, but they also have the same registers, which will simplify the creation of our structs. The two timers start initially at the frequency of the system clock, fsys = 80 MHz, but are divided differently. The PWM timer has a PSC of 7, which allows for a precise measurement of the timing, while the duration timer has a PSC of 7999, which allows for higher frequency resolution. This can be seen by reducing the PSC for both and seeing the wrong frequencies being produced and/or the note duration being too short if the clock is too fast.\nUsing the equations shown in Figures 1 and 2, we took advantage of the ARR (auto-reload register) which sets a value at which we want the timer’s counters to stop and reset. The pulse will stay HIGH until the counter counts to the value of ARR. This can be changed using the CCR1 register, which is set to half of the ARR value, meaning that the wave is set LOW when the counter reaches half of the ARR value. This produces a wave with 50 percent duty-cycle."
  },
  {
    "objectID": "labs/lab4/lab4.html#technical-documentation",
    "href": "labs/lab4/lab4.html#technical-documentation",
    "title": "Lab 4",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe Git repository containing the source code of this lab can be found here: Lab 4 Repo.\n\nDerivations and Calculations\nFigures 1 and 2 showcase derivation for equations that were used to determine ARR, as well as the period and the frequency of the note the system is outputting, Tnote and fnote. In Figure 3, we have the maximum/minimum frequency and duration calculations that provide justification as to why we decided to choose these prescaler PSC values. The reason why the PSC value is so important is mentioned in the Design and Testing Methodology section.\n\n\n\nFigure 1. Equations representing ARR and the resultant period, Tperiod, derived using the given equation for FCNT\n\n\n\n\n\nFigure 2. Derivation of ARR in terms of ticks per millisecond and the period of the note, Tnote. Equation for Tnote and fnote also derived.\n\n\n\n\n\nFigure 3. Minimum/maximum frequency and duration calculations.\n\n\n\n\nSchematic\n\n\n\nFigure 4. Schematic of the hardware level implementation used to verify operation.\n\n\nUsing an LM386 audio amplifier, the signal was amplified and could be controlled using a potentiometer. As shown in Figure 4, a circuit provided in amp’s datasheet is utilized in order to successfully amplify and control the volume of the signal"
  },
  {
    "objectID": "labs/lab4/lab4.html#results-and-discussion",
    "href": "labs/lab4/lab4.html#results-and-discussion",
    "title": "Lab 4",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe MCU was able to produce the correct frequencies that were provided to it for the exact duration that was specified for each note. While there were no testbenches for this specific lab, the notes and their durations were accurate using the selected values for PSC and ARR, as shown in Figure 5. Debugging here was important, so using Segger’s build and debug mode and forcing the pin to output one specific frequency was definitely very crucial to ensuring correct implementation.\n\n\n\nFigure 5. Spreadsheet showcasing the percent-error calculations for the frequency produced by the system.\n\n\n\n\nConclusion\nThe lab seemed to have no issues and was able to successfully play both Fur Elise and Mary Had a Little Lamb, but is not limited to either. This lab was definitely very difficult due to the abundance of information that had to be absorbed in order to understand what was going on. Now, I feel very able to set up registers and look through the manuals to find the correct information."
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype-summary",
    "href": "labs/lab4/lab4.html#ai-prototype-summary",
    "title": "Lab 4",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe AI was able to produce a pretty sensible response. I would attribute this to the fact that the information of our STM32 MCU is readily available, along with plenty of examples that the LLM can draw on. I will say that the AI did not mention the EGR register, which is crucial for this implementation to function properly. The LLM’s response is shown below:"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2",
    "section": "",
    "text": "In Lab 2, we used a setup similar to the one used in lab 1. This time, however, the goal was to power and program a switch-controlled dual seven-segment display using time-multiplexing and have 5 LEDs that form a binary representation of the sum of the independent switches controlling each display. Thanks to time-multiplexing, the two displays could be powered using the same number of GPIO pins by rapidly switching which display is actively getting powered at rate that makes the displays appear static to our eyes."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2",
    "section": "",
    "text": "In Lab 2, we used a setup similar to the one used in lab 1. This time, however, the goal was to power and program a switch-controlled dual seven-segment display using time-multiplexing and have 5 LEDs that form a binary representation of the sum of the independent switches controlling each display. Thanks to time-multiplexing, the two displays could be powered using the same number of GPIO pins by rapidly switching which display is actively getting powered at rate that makes the displays appear static to our eyes."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nSince this is functionally the same as what was done in lab 1 – controlling a display with a 4-bit input/switch – the seven_segment module from lab 1 could be reused, as long as the inputs rapidly switch according to the mux’s enable signal. Utilizing the same on-board high-speed oscillator (HSOSC) module that was used in lab 1, the clock signal was divided in order to drive the rate at which power is switched between displays. Using a 25-bit clock that is driven by the HSOSC’s clock signal, the mux module focuses on a specific bit of the clock in order to control the output of the mux, and the value of the enable signals, enable[0] and enable[1]. In this case, it was experimentally determined that the 18th bit of the counter, counter[18], allowed for the displays to appear static without any bleeding. Using two 2N3906 PNP transistors, the current could be selectively sent to one display at a time. Using GPIO pins, enable[0] and enable[1] were each sent to the base of an individual transistor, with the collector of the transistors each being routed to the power pins of one of the displays (more clearly shown in Figure 2).\nDepending on the value of counter[18], the mux within the mux module will output a 4-bit value, s, which will be equal to either s1 or s2 (which are 4-bit values controlled by independent switches), while the mux module updates the value of enable[0] and enable[1]. These changes are dictated by enable[0] = counter[18], enable[1] = ~counter[18], and s = counter[18] ? s1 : s2. In the top module, lab2_jc, the clock is generated using the HSOSC module then fed into the mux. The output, s, of the instantiated mux module is then fed into the seven_segment module that then decodes the value of s into its corresponding segments. These are then via GPIO to the display itself. The top module is also responsible for handling the sum of the two inputs, s1 and s2, which it then assigns to led[4:0]. It is important to note that the values of s1 and s2 control display 0 and 1, respectively."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe Git repository containing the source code of this lab can be found here: Lab 2 Repo.\n\nBlock Diagram\n\n\n\nFigure 1. Block diagram visualizing lab2_jc, seven_segment, and mux modules.\n\n\nThe block diagram shown in Figure 3 showcases the hierarchy and modules within the top level module, lab2_jc. This includes 3 submodules: HSOSC, mux, and seven_segment. An adder is also present since the top level module handles the sum of the two inputs.\n\n\nSchematic\n\n\n\nFigure 2. Schematic of the hardware level implementation used to verify operation.\n\n\nAs shown in Figure 2, the hardware used included: two 4-input dip switches, the UPduino, resistors for the base, seven segment display, and green LEDs, as well as the dual seven segment display itself. Pin assignments are also shown and the value the represent are also shown in the schematic."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\nFigure 3. Simulation of lab2_jc module used to verify operation.\n\n\nAs shown in Figure 3, the lab 2 workbench successfully demonstrated that the addition of the two input signals, s1 and s2, worked, as well as the switching of the enable signal.\n\n\n\nFigure 4. Simulation of mux module used to verify operation.\n\n\nAs shown in Figure 4, the mux testbench successfully demonstrated that the right output is provided given that enable[0] or enable[1] is high or low.\n\n\n\nFigure 5. Simulation of seven_segment module used to verify operation.\n\n\nAs shown in Figure 5, the seven_segment module successfully passed all the test vectors!\n\n\nConclusion\nIt appears that we were able to successfully control a dual seven segment display and 5 LEDs using two 4-input dip switches and time-multiplexing. Both of the testbenches ran and provided information that indicates that implementation was successful. I spent 20+ hours working on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab 2",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n  \n\n\n\nFigure 6. AI developed modules\n\n\nAfter prompting ChatGPT, it created the modules shown in Figure 6. The modules were able to compile successfully, but after a closer look, it was apparent that our approaches were slightly different, but I wasn’t entirely disappointed by the result. There are differences in syntax and the use of generate statements that I am not entirely familiar with, but the logic seems fine to me. It seems that they chose to utilize the positive and negative edges of the clock for the time-multiplexing, which is another apporoach I was thinking of when I began to develop my modules."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Jared Carreño is a senior engineering major at Harvey Mudd College. He is most focused on electrical and mechanical design interested in exploring embedded systems and full system design."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Hello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 23, 2024\n\n\nJared Carreno\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1",
    "section": "",
    "text": "Lab 1 was focused on setting up, testing, and getting familiarized with the UPduino v3.1 FPGA and Nucleo-L432KC development boards. This lab entailed soldering all the necessary components and headers onto the provided E155 development board, programming the MCU and FPGA boards with Segger Embedded Studio and Radiant Lattice, respectively, and creating modules that can control LEDs and an external seven segment display. The functionality of the design portion was verified using both simulation and hardware."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1",
    "section": "",
    "text": "Lab 1 was focused on setting up, testing, and getting familiarized with the UPduino v3.1 FPGA and Nucleo-L432KC development boards. This lab entailed soldering all the necessary components and headers onto the provided E155 development board, programming the MCU and FPGA boards with Segger Embedded Studio and Radiant Lattice, respectively, and creating modules that can control LEDs and an external seven segment display. The functionality of the design portion was verified using both simulation and hardware."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\n\n\nFigure 1. Truth table relating switch inputs to LEDs and seven segment display.\n\n\nAs shown in Figure 1, a 4-input switch will control both the seven segment display and 2 separate LEDs. The seven segment display consists of 7 LEDs that each correspond to a segment. Since the display is a common anode display, each segment will be activated when the GPIO pin that it is connected to is pulled to 0V, meaning that a value of 0 will indicate that a segment is ON. All the diodes’ anodes will be connected to 3.3V that comes directly from the UPduino, while the cathode will be connected to a GPIO pin and a current-limiting resistor. Combinational logic was used to drive LEDs 0 and 1, where led[0] = s[0] ^ s[1] and led[1] = s[2] & s[3], while LED 2 was set to constantly blink at a frequency of 2.4 Hz. This was done through the use of the built-in HSOSC (high speed oscillator) that was set to 48 MHz then divided to match the correct blinking frequency.\n\n\n\nFigure 2. Calculation of how many cycles will produce a correct blinking frequency of 2.4 Hz.\n\n\nAs shown in Figure 2, calculations were performed to determine how many cycles our counter would need to count to before turning off and then back on. It was determined that for 10,000,000 cycles our LED would have to be off and then on for another 10,000,000 cycles.\n\n\n\nFigure 3. Calculation of resistors to safely operate LEDs in the seven segment display.\n\n\nAs mentioned earlier, it was important to have resistors that limit the amount of current passing through our LEDs, so the appropriate resistance was calculated using the typical operating current and forward voltage (as shown in Figure 3). It is important to note that these calculations were made using an input voltage of 5V, instead of the required 3.3V, since there were difficulties getting adequate voltage out of the UPduino’s 3.3V pin. As shown in the top half of the Figure, it is recommended to use a resistor valued at 122 ohms or greater. Given that 1000 ohm resistors were used, the actual calculations would follow the bottom half of Figure 3."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe Git repository containing the source code of this lab can be found here: Lab 1 Repo.\n\nBlock Diagram\n\n\n\nFigure 4. Block diagram visualizing lab1_jc and seven_segment modules.\n\n\nThe block diagram shown in Figure 4 showcases the different modules and how they interact within the top level module. There are two inputs, s[3:0] and reset, an HSOSC module that is used to generate the clock, a counter that is used to blink LED 2, a seven_segment module containing all the combinational logic for the seven segment display, and combinational logic that is controlling LEDs 0 and 1.\n\n\nSchematic\n\n\n\nFigure 5. Schematic of the hardware level implementation used to verify operation, where R = 1k ohms.\n\n\nThe schematic shown in Figure 5 demonstrates the hardware setup used to verify the functionality of our modules. It showcases the switches utilized to control the seven segment display and LEDs, and how it maps to the physical GPIO pins on the UPduino. The schematic illustrates the use of 1000 ohm resistors to limit the current through both the onboard LEDs and the seven segment display’s LEDs."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\nFigure 6. Simulation of lab1_jc module used to verify operation.\n\n\nFigure 6 showcases the simulation of the lab1_jc module that is responsible for controlling both the LEDs and seven segment display. As we can see, the simulation managed to pass all 16 of the test vectors, meaning it was a successful implementation. As shown in Figure 6, the values of seg and led match their expected values, seg_expected and led_expected.\n\n\n\nFigure 7. Simulation of seven_segment module used to verify operation.\n\n\nFigure 7 showcases the simulation of the seven_segment module that is responsible for controlling the seven segment display. As we can see, the simulation managed to pass all 16 of the test vectors, meaning it was a successful implementation. As shown in Figure 6, the value of seg matches the value of seg_expected."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully blinked led[2] using the on-board HSOSC and controlled the seven segment display, as well as led[1] and led[0] using the 4-input dip switch. Both of the testbenches that were created for their respective modules yielded great success. I spent 10+ hours working on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab 1",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\n\n\nAI Response\n\n\nComparing this with my own module that controls the blinking of LED 2, it is immediately clear that the syntax and structure that the LLM utilizes is not easy to read. After attempting to synthesize, the design failed immediately. The AI was unable to successfully instantiate the HSOSC module that is utilized to generate the clock. Feeding the LLM the error message, it suggested that I reorder the inputs to the HSOSC module that it attempted to instantiate. Again, this didn’t work as it should be something like: HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk));. You would imagine that an LLM would be able to catch this simple of an issue, but it struggles. A majority of the code that the LLM produced is hard to read and/or wrong. There is also the use of language that I do not totally understand, since I am still somewhat new to Verilog. This leads me to believe there is some form of overcompensation and the LLM is making it unnecessarily complicated, since this isn’t exactly a complicated module to write. It’s shocking that the LLM is performing so terribly, but this may be due to the data that it is trained on."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3",
    "section": "",
    "text": "In Lab 3, we were tasked with utilizing a keypad that is very prone to mechanical debouncing in order to display numbers on a dual seven segment display that shifted from left to right as new inputs were introduced. This builds on concepts that were utilized in Labs 1 and 2."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab 3",
    "section": "",
    "text": "In Lab 3, we were tasked with utilizing a keypad that is very prone to mechanical debouncing in order to display numbers on a dual seven segment display that shifted from left to right as new inputs were introduced. This builds on concepts that were utilized in Labs 1 and 2."
  },
  {
    "objectID": "labs/lab3/lab3.html#design-and-testing-methodology",
    "href": "labs/lab3/lab3.html#design-and-testing-methodology",
    "title": "Lab 3",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe system was broken down into two FSMs: the scan FSM and debounce FSM:\nAs shown in Figure 3, the debounce FSM waits for keyPressed to be high, when it detects that it is high, it goes into S1 that enables a counter. Once the counter reaches 50ms and keyPressed is still high, then it moves onto S2 that sets pulse HIGH, indicating that there is a valid key press than can be displayed. If the key is still pressed after it is registered, keyPressed is still HIGH, so the FSM stays in S3 until the key is released, which restarts the FSM waiting for a valid press.\nAs shown in Figure 2, the scan FSM drives the columns and has a corresponding state for each row and column combination. Using row[3:0], it will jump to the state that corresponds to the column and row, and will set the corresponding column high using colOn[3:0], which cycles through one-hot encodings that enable each column, as the each state outputs row_col = {row, colOn}. The way this is designed ensures that there will be no states where multiple rows are pressed, attempting to limit the possibility of the wrong digits being shown"
  },
  {
    "objectID": "labs/lab3/lab3.html#technical-documentation",
    "href": "labs/lab3/lab3.html#technical-documentation",
    "title": "Lab 3",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe Git repository containing the source code of this lab can be found here: Lab 3 Repo.\n\nBlock Diagram and FSMs\n\n\n\nFigure 1. Block diagram visualizing the modules contained within the top module, lab3_jc\n\n\n\n\n\nFigure 2. FSM for scan module\n\n\n\n\n\nFigure 3. FSM for debounce module\n\n\n\n\nSchematic\n\n\n\nFigure 4. Schematic of the hardware level implementation used to verify operation."
  },
  {
    "objectID": "labs/lab3/lab3.html#results-and-discussion",
    "href": "labs/lab3/lab3.html#results-and-discussion",
    "title": "Lab 3",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nWhile there were no testbenches to verify using simulation, the hardware was mostly functional – shifting numbers from right to left (previous to most recent), only registering first key that is pressed, and display the second number held in the same column once the first is released. However, there is a issue when we attempt to switch to a different column from the same row, in which it won’t register the second press if two keys in the same row are pressed at the same time then the first one is released. Overall, it’s a pretty proficient implementation that will be improved on eventually.\n\n\nConclusion\nMy final product was able to successfully work – to an extent, which is further explained in the Results and Discussion section. Overall, this lab took 60+ hours to complete."
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype-summary",
    "href": "labs/lab3/lab3.html#ai-prototype-summary",
    "title": "Lab 3",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe code produced by the AI contained a lot of syntax errors that did not allow it to synthesize. Notably, it was attempting to find an ‘out’ port, which is not something that our modules are set up to have. There were originally some errors, like the AI creating modules of the same name, but even with some of my intervention the syntax errors were still prominent. The code is shown below:\n` module clock_divider( input logic clk, // 20 MHz input clock input logic rst_n, // Active low reset output logic scan_clk // Divided clock (100–200 Hz) ); // Target clock frequency: 100 Hz // Divider for 20 MHz: 20 MHz / 100 Hz = 200,000 logic [18:0] counter; // 19-bit counter for clock division\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter &lt;= 0;\n        scan_clk &lt;= 0;\n    end else begin\n        if (counter == 199_999) begin\n            counter &lt;= 0;\n            scan_clk &lt;= ~scan_clk;  // Toggle scan clock\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\nend\nendmodule\nmodule keypad_scanner1( input logic clk, // Clock input (scan clock) input logic rst_n, // Active low reset input logic [3:0] rows, // Row signals (active low) output logic [3:0] cols, // Column signals (active low) output logic [3:0] key // Output the detected key (hex value) ); // State machine for scanning rows and columns typedef enum logic [1:0] { IDLE = 2’b00, SCAN = 2’b01, DEBOUNCE = 2’b10 } state_t;\nstate_t state, next_state;\nlogic [3:0] column_reg, last_cols;\nlogic [3:0] key_reg, last_key;\nlogic key_pressed;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state &lt;= IDLE;\n        cols &lt;= 4'b1111;  // All columns inactive\n        key_reg &lt;= 4'b0000;\n        last_cols &lt;= 4'b1111;\n    end else begin\n        state &lt;= next_state;\n    end\nend\n\n// State machine logic\nalways_ff @(state or column_reg or rows or last_cols) begin\n    case (state)\n        IDLE: begin\n            next_state = SCAN;\n            cols = 4'b1111;  // All columns inactive\n        end\n        SCAN: begin\n            // Cycle through columns, one active at a time\n            if (column_reg == 4'b1110) column_reg = 4'b1101;\n            else if (column_reg == 4'b1101) column_reg = 4'b1011;\n            else if (column_reg == 4'b1011) column_reg = 4'b0111;\n            else column_reg = 4'b1111;\n            cols = column_reg;  // Set current column\n            key_pressed = |(rows & ~cols);  // Detect key press based on row signals\n            if (key_pressed) begin\n                key_reg = rows; // Register key press based on row active\n                next_state = DEBOUNCE;\n            end else begin\n                next_state = SCAN;\n            end\n        end\n        DEBOUNCE: begin\n            // Debounce the key by ensuring release before registering new key\n            if (~|(rows & ~cols)) begin  // No key pressed\n                next_state = SCAN;\n            end else begin\n                next_state = DEBOUNCE;\n            end\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// Output the detected key\nalways_ff @(posedge clk) begin\n    if (key_pressed) key = key_reg;\n    else key = last_key;\nend\nendmodule\nmodule keypad_one_shot_registration( input logic clk, // Clock input input logic rst_n, // Active low reset input logic [3:0] rows, // Row signals from keypad (active low) output logic new_key, // Single-cycle pulse for new key press output logic [3:0] key_code // Detected key code (hex value) ); // State machine states typedef enum logic [1:0] { IDLE = 2’b00, PRESSED = 2’b01, RELEASED = 2’b10 } state_t;\nstate_t state, next_state;  // Current and next states\nlogic [3:0] last_key;       // Store the last detected key\nlogic [3:0] current_key;    // Store the current key being pressed\n\n// Key detection: any active row means a key is pressed\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state &lt;= IDLE;\n        new_key &lt;= 0;\n        last_key &lt;= 4'b0000;\n        key_code &lt;= 4'b0000;\n    end else begin\n        state &lt;= next_state;\n    end\nend\n\n// Logic for key detection (rows are active low, check if any row is pressed)\nalways_ff @(posedge clk) begin\n    if (state == IDLE && ~(|rows)) begin\n        // Detect the key code when a key is pressed (active low rows)\n        current_key &lt;= ~rows;\n    end\nend\n\n// State transition and new key pulse generation\nalways_ff @(posedge clk) begin\n    case (state)\n        IDLE: begin\n            if (~(|rows)) begin  // Detect key press (any active row)\n                next_state &lt;= PRESSED;\n                new_key &lt;= 1;  // Generate a one-shot pulse\n            end else begin\n                next_state &lt;= IDLE;\n                new_key &lt;= 0;  // No new key, reset pulse\n            end\n        end\n\n        PRESSED: begin\n            if (~(|rows)) begin  // Key is still pressed\n                next_state &lt;= PRESSED;\n                new_key &lt;= 0;  // No new key until key is released\n            end else begin\n                next_state &lt;= RELEASED;  // Key released, move to RELEASED state\n            end\n        end\n\n        RELEASED: begin\n            if (~(|rows)) begin  // Key press has been released\n                next_state &lt;= IDLE;\n                key_code &lt;= current_key;  // Capture the key code\n                last_key &lt;= current_key;\n            end else begin\n                next_state &lt;= RELEASED;\n            end\n        end\n\n        default: begin\n            next_state &lt;= IDLE;\n        end\n    endcase\nend\nendmodule\nmodule keypad_scanner2( input logic clk, // Clock input (divided clock) input logic rst_n, // Active low reset input logic [3:0] rows, // Row signals from keypad (active low) output logic [3:0] key_code, // Detected key code (4-bit hex value) output logic key_pressed // Boolean indicating key press status );\n// Define FSM states\ntypedef enum logic [1:0] {\n    SCAN_IDLE = 2'b00,         // Wait for key press\n    SCAN_COL_0 = 2'b01,        // Scan column 0\n    SCAN_COL_1 = 2'b10,        // Scan column 1\n    SCAN_COL_2 = 2'b11         // Scan column 2\n} state_t;\n\nstate_t state, next_state;    // Current and next states\nlogic [3:0] col_mask;         // Column select mask\nlogic [3:0] detected_key;     // Detected key code (4 bits)\n\n// State machine for scanning columns\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state &lt;= SCAN_IDLE;\n        col_mask &lt;= 4'b1111;  // All columns inactive initially\n    end else begin\n        state &lt;= next_state;\n    end\nend\n\n// Column scanning logic: one column is active (low) at a time\nalways_ff @(posedge clk) begin\n    case (state)\n        SCAN_IDLE: begin\n            col_mask &lt;= 4'b1111;  // No column active\n        end\n        SCAN_COL_0: begin\n            col_mask &lt;= 4'b1110;  // Only column 0 is active (low)\n        end\n        SCAN_COL_1: begin\n            col_mask &lt;= 4'b1101;  // Only column 1 is active (low)\n        end\n        SCAN_COL_2: begin\n            col_mask &lt;= 4'b1011;  // Only column 2 is active (low)\n        end\n        default: begin\n            col_mask &lt;= 4'b1111;  // Default: no column active\n        end\n    endcase\nend\n\n// Detect the key code based on the active column and row signals\nalways_ff @(posedge clk) begin\n    case (state)\n        SCAN_COL_0: begin\n            if (~rows[0]) detected_key &lt;= 4'b0001;  // Row 0, Column 0\n            else if (~rows[1]) detected_key &lt;= 4'b0100;  // Row 1, Column 0\n            else if (~rows[2]) detected_key &lt;= 4'b0111;  // Row 2, Column 0\n            else if (~rows[3]) detected_key &lt;= 4'b1000;  // Row 3, Column 0\n        end\n        SCAN_COL_1: begin\n            if (~rows[0]) detected_key &lt;= 4'b0010;  // Row 0, Column 1\n            else if (~rows[1]) detected_key &lt;= 4'b0101;  // Row 1, Column 1\n            else if (~rows[2]) detected_key &lt;= 4'b0110;  // Row 2, Column 1\n            else if (~rows[3]) detected_key &lt;= 4'b1001;  // Row 3, Column 1\n        end\n        SCAN_COL_2: begin\n            if (~rows[0]) detected_key &lt;= 4'b0011;  // Row 0, Column 2\n            else if (~rows[1]) detected_key &lt;= 4'b0110;  // Row 1, Column 2\n            else if (~rows[2]) detected_key &lt;= 4'b0111;  // Row 2, Column 2\n            else if (~rows[3]) detected_key &lt;= 4'b1011;  // Row 3, Column 2\n        end\n        default: detected_key &lt;= 4'b0000; // Default: no key detected\n    endcase\nend\n\n// Key press indicator: Any key pressed when one of the rows is active\nalways_ff @(posedge clk) begin\n    if (~(|rows))  // If any row is active, a key is pressed\n        key_pressed &lt;= 1'b1;\n    else\n        key_pressed &lt;= 1'b0;\nend\n\n// Output the detected key code\nalways_ff @(posedge clk) begin\n    key_code &lt;= detected_key;\nend\n\n// State machine transitions: cycle through the columns\nalways_ff @(posedge clk) begin\n    case (state)\n        SCAN_IDLE: next_state &lt;= SCAN_COL_0;\n        SCAN_COL_0: next_state &lt;= SCAN_COL_1;\n        SCAN_COL_1: next_state &lt;= SCAN_COL_2;\n        SCAN_COL_2: next_state &lt;= SCAN_IDLE;\n        default: next_state &lt;= SCAN_IDLE;\n    endcase\nend\nendmodule\nmodule top_level ( input logic clk, // Clock from internal oscillator input logic rst_n, // Active low reset input logic [3:0] rows, // Row signals from keypad (active low) output logic [6:0] seg_a, // Seven segment display segments for first digit output logic [6:0] seg_b, // Seven segment display segments for second digit output logic an0, // Enable signal for first digit output logic an1 // Enable signal for second digit );\n// Signals for keypad scanner and one-shot registration\nlogic [3:0] key_code;         // Detected key code\nlogic new_key;                // New key detected (one-shot signal)\nlogic key_pressed;            // Key pressed indicator\n\n// Signals for last two keys\nlogic [3:0] most_recent_key;  // Most recent key (new key)\nlogic [3:0] older_key;        // Older key (last key)\n\n// Signals for 7-segment display\nlogic [3:0] display_digit;    // Digit to be displayed on the multiplexed display\nlogic mux_select;             // Multiplexer to select which digit to display\n\n// Instantiate the keypad scanner\nkeypad_scanner2 scanner (\n    .clk(clk),\n    .rst_n(rst_n),\n    .rows(rows),\n    .key_code(key_code),\n    .key_pressed(key_pressed)\n);\n\n// Instantiate the keypad one-shot registration module\nkeypad_one_shot_registration one_shot (\n    .clk(clk),\n    .rst_n(rst_n),\n    .rows(rows),\n    .new_key(new_key),\n    .key_code(key_code)\n);\n\n// Process for shifting the last two keys (older &lt;- most recent; most recent &lt;- new)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        most_recent_key &lt;= 4'b0000;\n        older_key &lt;= 4'b0000;\n    end else if (new_key) begin\n        // Shift the keys when a new key is detected\n        older_key &lt;= most_recent_key;\n        most_recent_key &lt;= key_code;\n    end\nend\n\n// Clock divider logic to generate a slower clock for display multiplexing\nlogic clk_display;\nreg [15:0] clk_divider;  // Divider for the clock (adjust for desired multiplexing rate)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_divider &lt;= 16'b0;\n        clk_display &lt;= 0;\n    end else begin\n        // Divide the clock to get a slower rate (e.g., 60 Hz for multiplexing)\n        if (clk_divider == 16'd49999) begin  // Adjust this value for desired rate\n            clk_divider &lt;= 16'b0;\n            clk_display &lt;= ~clk_display;  // Toggle the display clock\n        end else begin\n            clk_divider &lt;= clk_divider + 1'b1;\n        end\n    end\nend\n\n// Multiplexed display logic: alternate between displaying the two digits\nalways_ff @(posedge clk_display or negedge rst_n) begin\n    if (!rst_n) begin\n        mux_select &lt;= 0;\n        display_digit &lt;= 4'b0000;\n        an0 &lt;= 1;\n        an1 &lt;= 0;\n    end else begin\n        if (mux_select) begin\n            display_digit &lt;= most_recent_key;\n            an0 &lt;= 0;\n            an1 &lt;= 1;  // Enable second digit\n        end else begin\n            display_digit &lt;= older_key;\n            an0 &lt;= 1;  // Enable first digit\n            an1 &lt;= 0;\n        end\n        mux_select &lt;= ~mux_select;  // Toggle between the two digits\n    end\nend\n\n// Instantiate the seven-segment display decoder for both digits\nseven_segment seg1(\n    .in(display_digit),\n    .out(seg_a)\n);\n\nseven_segment seg2(\n    .in(display_digit),\n    .out(seg_b)\n);\nendmodule"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5",
    "section": "",
    "text": "In Lab 5, we were tasked with utilizing an STM32L432KC in order to read values of a provided motor’s built-in quadrature encoder in order to determine the speed of the motor (in rev/s). This was done through the use of interrupts that read every rising and falling edge of both of the quad. encoder’s signals, A and B, and correctly handling/interpreting the data being read using an interrupt"
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "Lab 5",
    "section": "",
    "text": "In Lab 5, we were tasked with utilizing an STM32L432KC in order to read values of a provided motor’s built-in quadrature encoder in order to determine the speed of the motor (in rev/s). This was done through the use of interrupts that read every rising and falling edge of both of the quad. encoder’s signals, A and B, and correctly handling/interpreting the data being read using an interrupt"
  },
  {
    "objectID": "labs/lab5/lab5.html#design-and-testing-methodology",
    "href": "labs/lab5/lab5.html#design-and-testing-methodology",
    "title": "Lab 5",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe overall approach here is simple: enable interrupts for two GPIO input pins and use those interrupts to either increment or decrement a counter depending on the direction and speed.\n\nInterrupts\nIn this implementation, the EXTI1 and EXTI2 fields within EXTICR1 were set to PA1 and PA2, respectively. Next, interrupts had to be enabled globally using the CMSIS provided _enable_irq() function. Using a mask bit, the IMR1 register was edited to allow for interrupts to be requested by our selected GPIO pins, while the RTSR1 and FTSR1 registers were modified to enable rising and falling edge triggers for the selected GPIO pins, respectively. Within the NVIC ISER register, EXTI interrupts were also enabled for PA1 and PA2.\nWithin the handlers, there were four cases to consider: rising/falling edges of A, rising/falling edges of B. As seen in Figure 2, when A is leading, the motor is spinning CW, and while B is leading the motor is spinning CCW. Focusing on the rising and falling edges of the leading signal and comparing it to the value of the other signal at the same moment will allow us to calculate the direction of rotation. As seen in Figure 2, the behavior of a motor spinning CW can be described by the two scenarios: A is rising when B is zero, and A falls when B is 1. The other two scenarios come from flipping the signals which will produce the opposite cases, meaning that the motor is spinning CCW. We use these four cases within the interrupt handler in order to determine whether or not to increment or decrement the counter. Using the counter, the velocity is calculated by dividing the counter by 4*PPR (pulses per revolution) provided by the spec. sheet in Figure 1.\n\n\n\nFigure 1. Specifications for quadrature encoder motor.\n\n\n\n\n\nFigure 2. Truth table for the quadrature encoder"
  },
  {
    "objectID": "labs/lab5/lab5.html#technical-documentation",
    "href": "labs/lab5/lab5.html#technical-documentation",
    "title": "Lab 5",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe Git repository containing the source code of this lab can be found here: Lab 5 Repo.\n\nVelocity Verification\nThe measured periods of the traces shown in Figure 3 were utilized to calculate the rev/s directly from the encoder’s output signal. I also recording a video of my motor spinning, calculated how long a single period was and utilized that value to calculate the revolutions per second. Calculations are shown in Figure 5.\n\n\n\nFigure 3. Traces of A and B signal when motor is running CCW at 12.00 V.\n\n\n\n\n\nFigure 4. Measurements of A and B signal when motor is running CCW at 12.00 V.\n\n\n\n\n\nFigure 5. Velocity verification calculations (using traces and manual recordings).\n\n\n\n\nPolling v.s. Interrupts\nGiven that interrupts are inherently faster since there are less processes, we already know that an interrupt-based approach is going to be faster than a polling-based approach. The issue arises in the fact that interrupts are event-driven while polling is time-driven. When an interrupt occurs, your pointer will jump into another address, the code will pause where the interrupt was triggered, and will jump back when it is done handling the interrupt. However, if we are polling every second, then in the time we are reading the values, we will miss a total of 4080 edges, since the code doesn’t pause while you’re reading any data (calculations shown in Figure 6).\n\n\n\nFigure 6. Calculations for the number of edges missed when polling with a delay of 1000 ms (1 s).\n\n\n\n\nFlowchart\n\n\n\nFigure 7. Flowchart of the entire system.\n\n\n\n\nSchematic\n\n\n\nFigure 8. Schematic of the hardware level implementation used to verify operation."
  },
  {
    "objectID": "labs/lab5/lab5.html#results-and-discussion",
    "href": "labs/lab5/lab5.html#results-and-discussion",
    "title": "Lab 5",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\n\nConclusion"
  },
  {
    "objectID": "labs/lab5/lab5.html#ai-prototype-summary",
    "href": "labs/lab5/lab5.html#ai-prototype-summary",
    "title": "Lab 5",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe code produced by the LLM appears to have a similar approach to my implementation, with a very noticeable difference being the use of UART clock. Even though my implementation uses printf(), it does so without a UART clock, so it’s interesting to see the AI take an approach with something I’ve never used before.\n// ======================================================================\n// ============================================================================\n// main.c\n// Quadrature encoder using EXTI interrupts + UART printf + direction\n// ============================================================================\n\n#include \"main.h\"\n\nvolatile int32_t encoder_count = 0;\nvolatile int32_t last_encoder_count = 0;\nvolatile float   encoder_velocity = 0.0f;\nvolatile int8_t  encoder_dir = 0;       // 1 = CW, -1 = CCW, 0 = stopped\nvolatile uint32_t print_counter = 0;\n\n// ---------------------------------------------------------------------------\n// UART2 initialization and printf redirection\n// ---------------------------------------------------------------------------\nvoid UART2_Init(void)\n{\n    // Enable GPIOA and USART2 clocks\n    RCC-&gt;AHB2ENR  |= RCC_AHB2ENR_GPIOAEN;\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_USART2EN;\n\n    // Configure PA2 (TX) and PA3 (RX) as AF7\n    GPIOA-&gt;MODER &= ~(GPIO_MODER_MODE2_Msk | GPIO_MODER_MODE3_Msk);\n    GPIOA-&gt;MODER |=  (0x2 &lt;&lt; GPIO_MODER_MODE2_Pos) | (0x2 &lt;&lt; GPIO_MODER_MODE3_Pos);\n    GPIOA-&gt;AFR[0] &= ~((0xF &lt;&lt; (2 * 4)) | (0xF &lt;&lt; (3 * 4)));\n    GPIOA-&gt;AFR[0] |=  (7 &lt;&lt; (2 * 4)) | (7 &lt;&lt; (3 * 4));  // AF7 = USART2\n\n    // Configure USART2: 115200 baud, 8N1\n    USART2-&gt;BRR = SystemCoreClock / 115200; // assuming APB1 = SystemCoreClock\n    USART2-&gt;CR1 = USART_CR1_TE | USART_CR1_RE | USART_CR1_UE;\n}\n\n// Retarget printf to USART2\nint __io_putchar(int ch)\n{\n    while (!(USART2-&gt;ISR & USART_ISR_TXE)); // wait for TX buffer empty\n    USART2-&gt;TDR = ch;\n    return ch;\n}\n\n// ---------------------------------------------------------------------------\n// Encoder + EXTI setup\n// ---------------------------------------------------------------------------\nvoid Encoder_Init(void)\n{\n    RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN;\n\n    // PA1 and PA2 as input with pull-ups\n    GPIOA-&gt;MODER &= ~(GPIO_MODER_MODE1_Msk | GPIO_MODER_MODE2_Msk);\n    GPIOA-&gt;PUPDR &= ~(GPIO_PUPDR_PUPD1_Msk | GPIO_PUPDR_PUPD2_Msk);\n    GPIOA-&gt;PUPDR |=  (1U &lt;&lt; GPIO_PUPDR_PUPD1_Pos) | (1U &lt;&lt; GPIO_PUPDR_PUPD2_Pos);\n\n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SYSCFGEN;\n\n    // Map EXTI lines to PA1, PA2 (EXTI1, EXTI2)\n    SYSCFG-&gt;EXTICR[0] &= ~(SYSCFG_EXTICR1_EXTI1_Msk | SYSCFG_EXTICR1_EXTI2_Msk);\n\n    EXTI-&gt;IMR1  |= (EXTI_IMR1_IM1 | EXTI_IMR1_IM2);\n    EXTI-&gt;RTSR1 |= (EXTI_RTSR1_RT1 | EXTI_RTSR1_RT2);\n    EXTI-&gt;FTSR1 |= (EXTI_FTSR1_FT1 | EXTI_FTSR1_FT2);\n\n    NVIC_SetPriority(EXTI1_IRQn, 2);\n    NVIC_EnableIRQ(EXTI1_IRQn);\n    NVIC_SetPriority(EXTI2_IRQn, 2);\n    NVIC_EnableIRQ(EXTI2_IRQn);\n}\n\n// ---------------------------------------------------------------------------\n// TIM2 1 ms periodic interrupt\n// ---------------------------------------------------------------------------\nvoid Timer2_Init(void)\n{\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\n\n    DELAY_TIM-&gt;PSC = (SystemCoreClock / 1000000) - 1; // 1 MHz tick\n    DELAY_TIM-&gt;ARR = 1000 - 1;                        // 1 ms overflow\n    DELAY_TIM-&gt;CNT = 0;\n    DELAY_TIM-&gt;DIER |= TIM_DIER_UIE;\n    DELAY_TIM-&gt;CR1  |= TIM_CR1_CEN;\n\n    NVIC_SetPriority(TIM2_IRQn, 3);\n    NVIC_EnableIRQ(TIM2_IRQn);\n}\n\n// ---------------------------------------------------------------------------\n// Compute velocity (called every 1 ms by TIM2 interrupt)\n// ---------------------------------------------------------------------------\nvoid compute_velocity(void)\n{\n    int32_t delta = encoder_count - last_encoder_count;\n    last_encoder_count = encoder_count;\n\n    // Determine direction based on delta sign\n    if (delta &gt; 0)      encoder_dir = 1;\n    else if (delta &lt; 0) encoder_dir = -1;\n    else                encoder_dir = 0;\n\n    // rev/s = delta / (PPR * 4 * 0.001s)\n    encoder_velocity = (float)delta / (PPR * 4.0f * 0.001f);\n}\n\n// ---------------------------------------------------------------------------\n// Encoder update helper\n// ---------------------------------------------------------------------------\nstatic inline void Encoder_Update(void)\n{\n    uint32_t A = (GPIOA-&gt;IDR & (1 &lt;&lt; 1)) ? 1 : 0;\n    uint32_t B = (GPIOA-&gt;IDR & (1 &lt;&lt; 2)) ? 1 : 0;\n\n    if (A == B)\n        encoder_count++;\n    else\n        encoder_count--;\n}\n\n// ---------------------------------------------------------------------------\n// Interrupt Handlers\n// ---------------------------------------------------------------------------\nvoid EXTI1_IRQHandler(void)\n{\n    if (EXTI-&gt;PR1 & EXTI_PR1_PIF1)\n    {\n        EXTI-&gt;PR1 = EXTI_PR1_PIF1;\n        Encoder_Update();\n    }\n}\n\nvoid EXTI2_IRQHandler(void)\n{\n    if (EXTI-&gt;PR1 & EXTI_PR1_PIF2)\n    {\n        EXTI-&gt;PR1 = EXTI_PR1_PIF2;\n        Encoder_Update();\n    }\n}\n\nvoid TIM2_IRQHandler(void)\n{\n    if (DELAY_TIM-&gt;SR & TIM_SR_UIF)\n    {\n        DELAY_TIM-&gt;SR &= ~TIM_SR_UIF;\n\n        compute_velocity();\n\n        // Print every 100 ms\n        print_counter++;\n        if (print_counter &gt;= 100)\n        {\n            print_counter = 0;\n\n            if (encoder_dir == 0)\n                printf(\"Stopped (0.00 rev/s)\\r\\n\");\n            else\n                printf(\"Speed: %.2f rev/s (%s)\\r\\n\",\n                       encoder_velocity * encoder_dir,   // signed speed\n                       (encoder_dir &gt; 0) ? \"CW\" : \"CCW\");\n        }\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Main\n// ---------------------------------------------------------------------------\nint main(void)\n{\n    SystemCoreClockUpdate();\n    UART2_Init();\n    Encoder_Init();\n    Timer2_Init();\n\n    printf(\"\\r\\nQuadrature Encoder + Direction Test Start\\r\\n\");\n\n    while (1)\n    {\n        __WFI(); // Sleep until interrupt\n    }\n}"
  }
]